---
title: 'Chapter 2: Transjunctional voltage is responsible for activity dependent gap
  junction modulation'
author: "Daniel R. Kick"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
## General ====
library("tidyverse") # Plotting and data manipulation
library(here)

## Statistics ====
library("nlme") # for nested anova via lme. See http://www.jason-french.com/tutorials/repeatedmeasures.html
library("multcomp")
library("car")
library("agricolae")
library(bayestestR)
library(rstanarm)
library(estimate)

library(equivalence)


## Plotting ====
library("cowplot") # clean up ggplots, plotgrid
library("ggthemes")
library("lemon")
library(Hmisc) # for mean_sdl ribbons
library("ggthemes")
library("ggsci")
library(see) # Utrum damnati futuri sint, qui non viderunt et crediderunt
library(patchwork)



## Specialty functions ====
source(here("R", "02MoniterGapJunction.R"))

## Global Params ====
# theme_set(kickme())
theme_set(theme_minimal())
library(broom) # for parameter estimates

# library("brms")
# 
# # fm <- brm(gj ~ Phase*Amp, 
# #           data = dplyr::filter(d, Time == 60),
# #           family = gaussian())
# # 
# # plot(fm, pars = c("Phase", "Amp"))
# # plot(marginal_effects(fm, effects = "Phase:Amp"))
# # 
# # stanplot(fm)
# 
# library(bayesplot)
# # fmm <- as.matrix(fm)
# # mcmc_areas(fmm,
# #            pars = c("b_Phase22.5", "b_Amplow", "b_Phase22.5:Amplow"),
# #            prob = 0.8)
# 
# # color_scheme_set("red")
# # ppc_dens_overlay(y = fm$,
# #                  yrep = posterior_predict(fmm, draws = 50))
# 
# 
# # fit %>%
# #   posterior_predict(draws = 500) %>%
# #   ppc_stat_grouped(y = mtcars$mpg,
# #                    group = mtcars$carb,
# #                    stat = "median")
# 
# 
# plot(estimate_density(fm))
# plot(p_direction(fm))
# 
```

#global todo
```{r}
# TODO Change all the file = paste0(working.dir, "/data/tecc.rds") to file = paste0("./data/tecc.rds")
ttock <- Sys.time()


```


```{r}


library("furrr")
plan(multiprocess)

make.resample.results <- T
save.resample.results <- T
write.resample.results <- T
load.resample.results <- F

# Run settings ----
# resample.results = T # If not TRUE resampled model list will be loaded from a previous save
resample.nreps <- 10000 #FIXME

# load.resample.results <- F
```


# Read in and aggregate data 
```{r read in data, eval=TRUE, include=FALSE}
# Preprocessing ----
working.dir <- getwd() #FIXME FYI, this should be the project root. Ideally this should have relied on `here`

tecc <- readRDS(file = paste0(working.dir, "/data/tecc.rds"))
tevc <- readRDS(file = paste0(working.dir, "/data/tevc.rds"))
htk <- readRDS(file = paste0(working.dir, "/data/htk.rds"))
a <- readRDS(file = paste0(working.dir, "/data/a.rds"))

tecc <- collapse_duplicate_gj_obs(tecc)
tevc <- collapse_duplicate_gj_obs(tevc)

## Reduce ionic current observations to a single one at a given target voltage. ====
### split into peak and end ####
# htk.p <- htk[, !(names(htk) %in% c("htk.end.mV", "htk.end.nA"))]
# htk.e <- htk[, !(names(htk) %in% c("htk.peak.mV", "htk.peak.nA"))]
# a.p <- a[, !(names(a) %in% c("a.end.mV", "a.end.nA"))]
# a.e <- a[, !(names(a) %in% c("a.peak.mV", "a.peak.nA"))]

### apply to each current type and time ####

# TODO this no longer works. (tested on R 3.6)
# htk.p <- collapse_duplicate_current_obs(
#   input.df = htk.p,
#   target.mV = 0,
#   prefer.pn = "online",
#   prefer.recording = "highest",
#   deduplicate = "closest"
# )
# 
# htk.e <- collapse_duplicate_current_obs(
#   input.df = htk.e,
#   target.mV = 0,
#   prefer.pn = "online",
#   prefer.recording = "highest",
#   deduplicate = "closest"
# ) 
# 
# a.p <- collapse_duplicate_current_obs(
#   input.df = a.p,
#   target.mV = 0,
#   prefer.pn = "",
#   prefer.recording = "highest",
#   deduplicate = "closest"
# )
# 
# a.e <- collapse_duplicate_current_obs(
#   input.df = a.e,
#   target.mV = 0,
#   prefer.pn = "",
#   prefer.recording = "highest",
#   deduplicate = "closest"
# )


## Join independent data types into a single data frame ====

#FIXME see above
all.data <- full_join(tecc, tevc) %>% full_join(htk) %>% full_join(a)

#%>% full_join(htk.p) %>% full_join(htk.e) %>% full_join(a.p) %>% full_join(a.e) 
all.data <- all.data[, c(
  "Condition", "Experiment", "Time", "Inj_Cell",
  "tecc.recording", "tevc.recording", 
  #"htk.recording", "a.recording", "subtracted.rin",
  "r11", "r12", "r1", "rc", "cc", "rmp", "gj",
  #"htk.peak.mV", "htk.peak.nA", "htk.end.mV", "htk.end.nA",
  #"a.peak.mV", "a.peak.nA", "a.end.mV", "a.end.nA"
  "intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk", 
  "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a"
  
)]

all.data <- all.data %>% as.data.frame()
```

```{r}
## Rename conditions ====
rename.df <- as.data.frame(list(
  c("Aberrant Depol", "PS.0.High.Amp"), 
  c("Aberrant_Depol_22.5_deg", "PS.22.High.Amp"), 
  
  c("HA 90 Degree", "PS.90.HA"), 
  c("HA 90 Degree Cd", "PS.90.HA.Cd"), 
  
  c("0_deg", "PS.0"), 
  c("22.5_degrees", "PS.22"), 
  c("rep 45 Degree", "PS.45"), 
  c("rep 90 Degree", "PS.90"), 
  
  c("PS.0.orig", "PS.0.orig"), 
  c("PS.22.orig", "PS.22.orig"), 
  c("PS.45.orig", "PS.45.orig"),
  c("PS.90.orig", "PS.90.orig"), 
  c("PS.180.orig", "PS.180.orig"), 
  
  c("hold_at_-53mV", "Silent.53mV"), 
  c("TEA_ControlWave", "PS.0.TEA"),
  c("PS.0.TEA", "PS.0.TEA"),
  c("TEA_Silent", "Silent.TEA"), 
  c("Inverted Wave", "Inv"), 
  
  c("TEA.Active", "TEA.Active")
))

rename.df <- as.data.frame(t(rename.df))
names(rename.df) <- c("old", "new")
rownames(rename.df) <- NULL # get rid of rownames

all.data$changed <- F
for (i in seq(1, nrow(rename.df))){
  all.data[all.data$Condition == as.character(rename.df[i, "old"]), "Condition"] <- as.character(rename.df[i, "new"])
  all.data[all.data$Condition == as.character(rename.df[i, "old"]), "changed"] <- T
}
# print out the unchanged rows
print(all.data[!all.data$changed & !(all.data$Condition %in% as.vector(rename.df[, "new"])), ])
#and drop
all.data <- all.data[, !(names(all.data) %in% c("changed"))] 

# reorder factors
all.data$Condition <- factor(all.data$Condition, as.vector(rename.df[, "new"]) )

# #NOTE: this needs to be changed if new conditions are added
# 
# conditions <- all.data$Condition %>% unique()
# 
# new.conditions <- c("PS.0.High.Amp", "Inv", "PS.0", "PS.0.TEA", "Silent.TEA", "PS.22", "PS.22.High.Amp", "PS.22.orig", "PS.45", 
#                     "PS.90",
#                     "HA 90 Degree",
#                     "Silent.53mV",  "PS.0.orig", "PS.180.orig", "PS.90.orig", "PS.45.orig",
#                     "TEA.Active") #FIXME
# 
# 
# 
# 
# # new.conditions <- c("PS.0.High.Amp", "Inv", "PS.0", "PS.0.TEA", "Silent.TEA", "PS.22", "PS.22.High.Amp", "PS.22.orig", "PS.45", 
# #                     "PS.90",
# #                     "HA 90 Degree",
# #                     "Silent.53mV",  "PS.0.orig", "PS.180.orig", "PS.90.orig", "PS.45.orig",
# #                     "TEA.Active") #FIXME
# 
# for (i in 1:length(conditions)) {
#   all.data[all.data$Condition == conditions[i], "Condition" ] <- new.conditions[i]
# }
# 
# # reorder factors
# all.data$Condition <- factor(all.data$Condition, c(
#   "PS.0", "PS.22", "PS.45", 
#   "PS.90",
#   "HA 90 Degree",
#   "PS.0.High.Amp", "PS.22.High.Amp", 
#   "PS.0.orig", "PS.22.orig", "PS.45.orig", "PS.90.orig", "PS.180.orig", 
#   "PS.0.TEA", "Silent.TEA", "Inv", "Silent.53mV",
#   "TEA.Active"
# ))

### NOTE: setting silent TEA to PS0TEA: ####
#ignore silent TEA
# all.data[all.data$Condition == "Silent.TEA", "Condition"] <- "PS.0.TEA"

## Drop outliers by the following rules: ====

#convert gj to inverse to make it easier to work with.
all.data$gj <- (1/all.data$gj) 
```


QC
```{r}
### 1. Resistances can't be zero, drop any which are.  ####
all.data[(all.data$r11 < 0) & !is.na(all.data$r11) , "r11"] <- NA
all.data[(all.data$r1 < 0) & !is.na(all.data$r1) , "r1"] <- NA
all.data[(all.data$rc < 0) & !is.na(all.data$rc) , "rc"] <- NA
all.data[(all.data$gj < 0) & !is.na(all.data$gj) , "gj"] <- NA

# 2. If coupling coef is less than 0 or above 1, drop it. ####
all.data[(all.data$cc > 1 | all.data$cc < 0) & !is.na(all.data$cc) , "cc"] <- NA

# for condition | time | response var
conditions <- all.data$Condition %>% unique()
times <- all.data$Time %>% unique()
response.vars <- c("r11", "r1", "cc", "a.peak.nA", "htk.peak.nA", "rc", "gj")

multiplier <-  2
use.method <- "use.sd" #use.iqr

tic <- Sys.time()
for (i in seq_along(conditions)) {
  for (j in seq_along(times)) {
    for (k in seq_along(response.vars)) {
      if (use.method == "use.sd") {
        current.mean <- all.data[all.data$Condition == conditions[i] &
          all.data$Time == times[j], response.vars[k]] %>% mean(na.rm = TRUE)
        current.sd <- all.data[all.data$Condition == conditions[i] &
          all.data$Time == times[j], response.vars[k]] %>% sd(na.rm = TRUE)

        all.data[all.data$Condition == conditions[i] & all.data$Time == times[j] & ((all.data[[response.vars[k]]] < (current.mean - (multiplier * current.sd))) | (all.data[[response.vars[k]]] > (current.mean + (multiplier * current.sd)))) & !(is.na(all.data[[response.vars[k]]])), response.vars[k]] <- NA
      } else if (use.method == "use.iqr") {
        current.median <- all.data[all.data$Condition == conditions[i] &
          all.data$Time == times[j], response.vars[k]] %>% median(na.rm = TRUE)
        current.iqr <- all.data[all.data$Condition == conditions[i] &
          all.data$Time == times[j], response.vars[k]] %>% IQR(na.rm = TRUE)

        all.data[all.data$Condition == conditions[i] & all.data$Time == times[j] & ((all.data[[response.vars[k]]] < (current.median - (multiplier * current.iqr))) | (all.data[[response.vars[k]]] > (current.median + (multiplier * current.iqr)))) & !(is.na(all.data[[response.vars[k]]])), response.vars[k]] <- NA
      } else {
        warning(paste(as.character(use.method), "is not use.sd or use.iqr!"))
      }
    }
  }
}
print(Sys.time() - tic)
```


### Reduce dataset


```{r}
# Reduce data to target times ----
all.data <- all.data[all.data$Time %in% c(0, 20, 40, 60) |
                       all.data$Condition == "TEA.Active", ]

```



## Drop questionable observation
```{r}
all.data <- all.data[all.data$Experiment != "170817a",]
```

### Calculate deltas and percent changes 
```{r}
## Calculate percent change for later use: ====
all.data.p <- convert_data_to(
  input.df = all.data,
  convert.to = c("percent"),
  data.cols = c(
    "r11", "r12", "r1", "rc", "cc", "rmp", "gj",
    #FIXME as above, so below
    "intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk", 
    "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a"
    # "htk.peak.mV", "htk.peak.nA", "htk.end.mV", "htk.end.nA",
    # "a.peak.mV", "a.peak.nA", "a.end.mV", "a.end.nA"
  )
)



all.data.d <- convert_data_to(
  input.df = all.data,
  convert.to = c("difference"),
  data.cols = c(   "r11", "r12", "r1", "rc", "cc", "rmp", "gj",
                   #FIXME as above, so below
                   "intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk", 
                   "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a"
                   # "htk.peak.mV", "htk.peak.nA", "htk.end.mV", "htk.end.nA",
                   # "a.peak.mV", "a.peak.nA", "a.end.mV", "a.end.nA"
  )
)

M <- all.data#[all.data$Time %in% c(0, 20, 40, 60) , ]
M.p <- all.data.p#[all.data.p$Time %in% c(0, 20, 40, 60) , ]
M.d <- all.data.d#[all.data.d$Time %in% c(0, 20, 40, 60) , ] 

## Deduplicate gap junction measurements ====
M.gj<- deduplicate_gj_obs(input.df = M)
M.p.gj<- deduplicate_gj_obs(input.df = M.p)
M.d.gj <- deduplicate_gj_obs(input.df = M.d)
```


# Drop questionable observations
```{r drop questionable data}
# #there are some experiment timepoints which need to be replaced wholesale and others which have a duplicated that behaves oddly. To clean up this data I have dropped the following duplicated values
# df.tevc_gj$drop <- FALSE
# 
# 
# df.tevc_gj[df.tevc_gj$Experiment == "180214" & 
#              df.tevc_gj$`Time Exposed` == 40 & 
#              df.tevc_gj$inj_in_IN4 == F &
#              df.tevc_gj$Recording == 38, "drop"] <- TRUE
# 
# df.tevc_gj[df.tevc_gj$Experiment == "180212" & 
#              df.tevc_gj$`Time Exposed` == 40 & 
#              df.tevc_gj$inj_in_IN4 == F &
#              df.tevc_gj$Recording == 50, "drop"] <- TRUE #%>% hist()
# 
# df.tevc_gj[df.tevc_gj$Experiment == "180214" & 
#              df.tevc_gj$`Time Exposed` == 40 & 
#              df.tevc_gj$inj_in_IN4 == T &
#              df.tevc_gj$Recording == 42, "drop"] <- TRUE
# 
# df.tevc_gj[df.tevc_gj$Experiment == "180212" & 
#              df.tevc_gj$`Time Exposed` == 40 & 
#              df.tevc_gj$inj_in_IN4 == T &
#              df.tevc_gj$Recording == 50, "drop"] <- TRUE
# 
# df.tevc_gj[df.tevc_gj$Experiment == "180125" & 
#              df.tevc_gj$`Time Exposed` == 0 & 
#              df.tevc_gj$inj_in_IN4 == T &
#              df.tevc_gj$Recording == 43, "drop"] <- TRUE
# 
# df.tevc_gj[df.tevc_gj$Experiment == "180507" & #Looks like voltage sensing electrode in IN9 was slipping out. Ihtk like activity. 
#              df.tevc_gj$`Time Exposed` == 40 & 
#              df.tevc_gj$inj_in_IN4 == F &
#              df.tevc_gj$Recording == 13, "drop"] <- TRUE
# 
# df.tevc_gj <- df.tevc_gj[df.tevc_gj$drop != TRUE, ]
# df.tevc_gj <- df.tevc_gj[, !(names(df.tevc_gj) %in% c("drop"))]
# 
# #df.tevc_gj[df.tevc_gj$Experiment == "180125" & 
# #               df.tevc_gj$`Time Exposed` == 0 & 
# #               df.tevc_gj$inj_in_IN4 == T, c("Recording", "gj")]
```

> Seems to contain at least some of the to drop points.
[1] 1.235307
numeric(0)
[1] 1.431159
numeric(0)
numeric(0)
[1]       NA 3.821254

```{r}
# # df.tevc_gj[df.tevc_gj$Experiment == "180214" & 
# #              df.tevc_gj$`Time Exposed` == 40 & 
# #              df.tevc_gj$inj_in_IN4 == F &
# #              df.tevc_gj$Recording == 38, "drop"] <- TRUE
# # 
# # df.tevc_gj[df.tevc_gj$Experiment == "180212" & 
# #              df.tevc_gj$`Time Exposed` == 40 & 
# #              df.tevc_gj$inj_in_IN4 == F &
# #              df.tevc_gj$Recording == 50, "drop"] <- TRUE #%>% hist()
# # 
# # df.tevc_gj[df.tevc_gj$Experiment == "180214" & 
# #              df.tevc_gj$`Time Exposed` == 40 & 
# #              df.tevc_gj$inj_in_IN4 == T &
# #              df.tevc_gj$Recording == 42, "drop"] <- TRUE
# # 
# # df.tevc_gj[df.tevc_gj$Experiment == "180212" & 
# #              df.tevc_gj$`Time Exposed` == 40 & 
# #              df.tevc_gj$inj_in_IN4 == T &
# #              df.tevc_gj$Recording == 50, "drop"] <- TRUE
# # 
# # df.tevc_gj[df.tevc_gj$Experiment == "180125" & 
# #              df.tevc_gj$`Time Exposed` == 0 & 
# #              df.tevc_gj$inj_in_IN4 == T &
# #              df.tevc_gj$Recording == 43, "drop"] <- TRUE
# # 
# # df.tevc_gj[df.tevc_gj$Experiment == "180507" & #Looks like voltage sensing electrode in IN9 was slipping out. Ihtk like activity. 
# #              df.tevc_gj$`Time Exposed` == 40 & 
# #              df.tevc_gj$inj_in_IN4 == F &
# #              df.tevc_gj$Recording == 13, "drop"] <- TRUE
# 
# 
# present.vars <- data.frame(exp = c("180214", "180212", "180214", "180212", "180125", "180507"),
# rec = c(38,50,42,50,43,13))
# for (i in 1:nrow(present.vars)){
#   print(unique(M[M$Experiment == present.vars[i, "exp"] &
#   M$tevc.recording == present.vars[i, "rec"] , c("gj")]))
# }
```

```{r eval=FALSE, include=FALSE}
# # Get ballanced groups ----
# all.data <- all.data[(all.data$Condition == "PS.0" &
#   all.data$Experiment %in% c(
#     "180507",
#     "180509",
#     "180509a",
#     "180510",
#     "180514"
#   )) |
#   all.data$Condition != "PS.0", ]
# 
# all.data <- all.data[(all.data$Condition == "PS.22" &
#   all.data$Experiment %in% c(
#     "180315", 
#     "180314", 
#     "180309", #real high
#     # "180308", #real low, t=0 measures furthest apart
#     "180705", 
#     "181001"
#   )) |
#   all.data$Condition != "PS.22", ]
# 
# all.data <- all.data[(all.data$Condition == "PS.45" &
#   all.data$Experiment %in% c(
#     "180413",  
#     "180425",  
#     "180622",  
#     "180625",  
#     "190404a"
#   )) |
#   all.data$Condition != "PS.45", ]
# 
# all.data <- all.data[(all.data$Condition == "PS.90" &
#   all.data$Experiment %in% c(
#     "190319", 
#     "190319a", 
#     "190322",  
#     "190322a", 
#     "190404"
#   )) |
#   all.data$Condition != "PS.90", ]
# 
# all.data <- all.data[(all.data$Condition == "PS.22.High.Amp" &
#   all.data$Experiment %in% c(
#     "180604", 
#     "180607", 
#     "180615", 
#     "180530", 
#     "180531"
#   )) |
#   all.data$Condition != "PS.22.High.Amp", ]
# 
# all.data <- all.data[(all.data$Condition == "PS.0.High.Amp" &
#   all.data$Experiment %in% c(
#    "180221",  
#     "180221a", 
#     #"180212",  
#     "180214",  
#     "181019",  
#     "180223"
#   )) |
#   all.data$Condition != "PS.0.High.Amp", ]
# 
# 
# # PS.0
# # "180507",
# # "180509",
# # "180509a",
# # "180510",
# # "180514"
# 
# # PS.22
# # "180315", 
# # "180314", 
# # "180309", #real high
# # # "180308", #real low, t=0 measures furthest apart
# # "180705", 
# # "181001"
# 
# # PS.45
# # "180413",  
# # "180425",  
# # "180622",  
# # "180625",  
# # "190404a"
# 
# # PS.90
# # "190319", 
# # "190319a", 
# # "190322",  
# # "190322a", 
# # "190404"
#  
# # PS.22.High.Amp
# # "180604", 
# # "180607", 
# # "180615", 
# # "180530", 
# # "180531"
# 
# # PS.0.High.Amp
# # "180221",  
# # "180221a", 
# # #"180212",  
# # "180214",  
# # "181019",  
# # "180223"

```



```{r}
M.d.gj$Condition %>% unique()
```



# remaking `d`

```{r}
# note that this function is designed to work only with this dataset.
add_stim_delay_phase <- function(d = M.d){
  d <- d %>% filter(Condition %in% c(
    "PS.0.High.Amp",
    "PS.22.High.Amp",
    
    "PS.90.HA",
    "PS.90.HA.Cd",
    
    "PS.0",
    "PS.22",
    "PS.45",
    "PS.90",
    
    "PS.0.orig", 
    "PS.22.orig",
    "PS.45.orig",
    "PS.90.orig",   
    "PS.180.orig"
    
  )) %>%  mutate(Condition = as.character(Condition))
  
  
  d$Stim <- ""
  d$Delay <- ""
  d$Phase <- ""
  
  ## Add stim type col ====
  d[d$Condition %in% c("PS.0", 
                       "PS.22", 
                       "PS.45", 
                       "PS.90"), "Stim"] <- "Standardized"
  
  d[d$Condition %in% c(  "PS.0.orig",
                         "PS.22.orig",
                         "PS.45.orig",
                         "PS.90.orig",
                         "PS.180.orig"), "Stim"] <- "Naturalistic"
  
  d[d$Condition %in% c(  "PS.0.High.Amp",
                         "PS.22.High.Amp"), "Stim"] <- "High Voltage Long"
  
  d[d$Condition %in% c("PS.90.HA",
                       "PS.90.HA.Cd"), "Stim"] <- "High Voltage Short"
  
  ## Add delay seconds col ====
  d[d$Condition %in% c("PS.0", "PS.0.orig", "PS.0.High.Amp"), "Delay"] <- "0.00"
  d[d$Condition %in% c("PS.22.High.Amp"), "Delay"] <- "0.59"
  d[d$Condition %in% c("PS.90.HA", "PS.90.HA.Cd"), "Delay"] <- "0.98"
  
  d[d$Condition %in% c("PS.22"), "Delay"] <- "0.24"
  d[d$Condition %in% c( "PS.45"), "Delay"] <- "0.49"
  d[d$Condition %in% c("PS.90"), "Delay"] <- "0.98"
  
  ## Add delay phase col ====
  d[d$Condition %in% c(  "PS.0", "PS.0.orig", "PS.0.High.Amp","Silent.53mV", "PS.0.TEA",  "Inv"), "Phase"] <- "0"
  d[d$Condition %in% c(  "PS.22", "PS.22.orig","PS.22.High.Amp"), "Phase"] <- "22.5"
  d[d$Condition %in% c(  "PS.45", "PS.45.orig"), "Phase"] <- "45"
  d[d$Condition %in% c("PS.90", "PS.90.orig"), "Phase"] <- "90"
  d[d$Condition %in% c(  "PS.180.orig"), "Phase"] <- "180"
  
  ## Rename conditions ====
  
  d[d$Condition == "PS.0.High.Amp", "Condition"] <- "TEA Mimic Sync"
  d[d$Condition == "PS.22.High.Amp", "Condition"] <- "TEA Mimic Async"
  
  d[d$Condition == "PS.90.HA", "Condition"] <- "High Amplitude Async"
  d[d$Condition == "PS.90.HA.Cd", "Condition"] <- "High Amplitude Async Cd2+"
  
  d[d$Condition == "PS.0", "Condition"] <- "Low mV 0 Deg."
  d[d$Condition == "PS.22", "Condition"] <- "Low mV 22.5 Deg."
  d[d$Condition == "PS.45", "Condition"] <- "Low mV 45 Deg."
  d[d$Condition == "PS.90", "Condition"] <- "Low mV 90 Deg."
  
  d[d$Condition == "PS.0.orig", "Condition"] <- "Natural 0 Deg."
  d[d$Condition == "PS.22.orig", "Condition"] <- "Natural 22.5 Deg."
  d[d$Condition == "PS.45.orig", "Condition"] <- "Natural 45 Deg."
  d[d$Condition == "PS.90.orig", "Condition"] <- "Natural 90 Deg."
  d[d$Condition == "PS.180.orig", "Condition"] <- "Natural 180 Deg."
  
  ## Make into factors ====
  d$Stim <- as.factor(d$Stim)
  d$Delay <- as.factor(d$Delay)
  d$Phase <- as.factor(d$Phase)
  d <- d %>% mutate(Condition = as.factor(Condition))
  
  ## Relevel ====
  d$Stim <- factor(d$Stim, levels = c("High Voltage Long", "High Voltage Short", "Standardized", "Naturalistic"))
  d$Delay <- factor(d$Delay, levels = c("0.00", "0.24", "0.49", "0.59", "0.98"))
  d$Phase <- factor(d$Phase, levels = c("0", "22.5", "45", "90", "180"))
  
  d$Condition <- factor(d$Condition, levels = c(
    "TEA Mimic Sync" ,
    "TEA Mimic Async",
    
    "High Amplitude Async",
    "High Amplitude Async Cd2+",
    
    "Low mV 0 Deg.",
    "Low mV 22.5 Deg.",
    "Low mV 45 Deg.",
    "Low mV 90 Deg.",
    
    "Natural 0 Deg.",
    "Natural 22.5 Deg.",
    "Natural 45 Deg.",
    "Natural 90 Deg.",
    "Natural 180 Deg."
  ))
  
  return(d)
}

sfn_Rc_ggplot <- function(df, yvar = "rc", colorvals = c("#d95f0e", "#993404",
                                            "#a6bddb", "#74a9cf", "#2b8cbe", "#045a8d",
                                            "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32")){
  ggplot(df, aes_string("Time", yvar, fill = "Condition"))+
    geom_hline(yintercept = 0, color = "black")+
    stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "ribbon", alpha = 0.2)+
    stat_summary(fun = mean, geom = "point", aes(color = Condition), size = 5, color = "white", alpha = 0.7) +
    stat_summary(fun = mean, geom = "point", aes(color = Condition), size = 5, color = "black", shape = 1, alpha = 0.7) +
    stat_summary( fun = mean, geom = "line", aes(color = Condition), size = 1, linetype = 1 , color = "white") +
    
    geom_line(aes(group = inter, color = Condition))+
    geom_point(aes(group = inter, color = Condition))+
    geom_pointline(aes(group = inter, color = Condition))+
    
    labs(y = expression(paste(Delta, "Rc", " in M", Omega)), x = "Time in Minutes")+
    facet_grid(. ~ Condition)+
    scale_color_manual(values = colorvals)+
    scale_fill_manual(values = colorvals)+
    theme(legend.position = "")
}
```

### refresh STG meeting figures ====
```{r eval=FALSE, include=FALSE}
d <- add_stim_delay_phase(d = M.d)
d$inter <- paste0(d$Experiment, ".", d$Inj_Cell)
# yvar = "gj"

## mimic first poster plot ====
plt.sfn.all.1 <- sfn_Rc_ggplot(
  df = filter(d, Condition %in% c(  
    "TEA Mimic Sync" ,
    "TEA Mimic Async",
    # "High Amplitude Async",
    # "High Amplitude Async Cd2+",
    "Low mV 0 Deg.",
    "Low mV 22.5 Deg.",
    "Low mV 45 Deg.",
    "Low mV 90 Deg."#,
    # "Natural 0 Deg.",
    # "Natural 22.5 Deg.",
    # "Natural 45 Deg.",
    # "Natural 90 Deg.",
    # "Natural 180 Deg."
  )),
  yvar = "gj", 
  colorvals = c(
    "#d95f0e", 
    "#993404",
    
    # "#F816AB", 
    # "#D1416F",
    
    "#a6bddb", 
    "#74a9cf", 
    "#2b8cbe", 
    "#045a8d",
    
    "#a1d99b", 
    "#74c476", 
    "#41ab5d", 
    "#238b45", 
    "#005a32"
  )
)+ylim(-4, 4)#NOTE! THIS IS NOT COORD CARTESIAN

## mimic second poster plot ====
plt.sfn.all.2 <- sfn_Rc_ggplot(
  df = filter(d, Condition %in% c(  
    # "TEA Mimic Sync" ,
    # "TEA Mimic Async",
    # # "High Amplitude Async",
    # # "High Amplitude Async Cd2+",
    # "Low mV 0 Deg.",
    # "Low mV 22.5 Deg.",
    # "Low mV 45 Deg.",
    # "Low mV 90 Deg."#,
    "Natural 0 Deg.",
    "Natural 22.5 Deg.",
    "Natural 45 Deg.",
    "Natural 90 Deg.",
    "Natural 180 Deg."
  )),
  yvar = "gj", 
  colorvals = c(
    # "#d95f0e", 
    # "#993404",
    # 
    # # "#F816AB", 
    # # "#D1416F",
    # 
    # "#a6bddb", 
    # "#74a9cf", 
    # "#2b8cbe", 
    # "#045a8d",
    
    "#a1d99b", 
    "#74c476", 
    "#41ab5d", 
    "#238b45", 
    "#005a32"
  )
)+ylim(-4, 4)#NOTE! THIS IS NOT COORD CARTESIAN

## saving ====
# ggsave(
#       "SFN_all1.tiff",
#       plot = plt.sfn.all.1, #ggplot2::last_plot(),
#       device = NULL,
#       path = paste0(getwd(), "/data/figures"),
# width = 20, height = 9.67,
#       # units = c("in", "cm", "mm"),
#       dpi = 175#, limitsize = TRUE, ...
#     )
# 
# ggsave(
#       "SFN_all2.tiff",
#       plot = plt.sfn.all.2, #ggplot2::last_plot(),
#       device = NULL,
#       path = paste0(getwd(), "/data/figures"),
# width = 20, height = 9.67,
#       # units = c("in", "cm", "mm"),
#       dpi = 175#, limitsize = TRUE, ...
#     )
```

### figures going forward ====

```{r}
d <- add_stim_delay_phase(d = M.d)
d$inter <- paste0(d$Experiment, ".", d$Inj_Cell)
# yvar = "rc"

# Manual QC wonky points ----
## gj ====
#TEA sync
d[d$inter == "180212.LC4" & d$Time %in% c(40), "gj"] <- NA
# ps0
d[d$inter == "180507.LC4" & d$Time %in% c(40), "gj"] <- NA
# natural 0
d[d$inter == "170711e.LC4" & d$Time %in% c(20), "gj"] <- NA
d[d$inter == "170814b.LC5" & d$Time %in% c(60), "gj"] <- NA
# natural 22.5
 
#  natural 45
d[d$inter == "170925A.LC5" & d$Time %in% c(20), "gj"] <- NA
d[d$inter == "170925A.LC4" & d$Time %in% c(20, 40), "gj"] <- NA

# natural 90
d[d$inter == "170803a.LC4" & d$Time %in% c(20), "gj"] <- NA

# natural 180
d[d$inter == "170801a.LC5" & d$Time %in% c(20), "gj"] <- NA


## rc ====
d[d$inter == "180507.LC4" & d$Time %in% c(40), "rc"] <- NA
d[d$inter == "181001.LC4" & d$Time %in% c(40, 60), "rc"] <- NA


#natural 22.5
d[d$inter == "180718a.LC5" & d$Time %in% c(20), "rc"] <- NA
# natural 180
d[d$inter == "170801a.LC5" & d$Time %in% c(20), "rc"] <- NA

```


```{r eval=FALSE, include=FALSE}
# Plot ----
p1 <- sfn_Rc_ggplot(
  df = filter(d, Condition %in% c(
    "TEA Mimic Sync",
    "TEA Mimic Async",
    "High Amplitude Async",
    "High Amplitude Async Cd2+"#,
    # "Low mV 0 Deg.",
    # "Low mV 22.5 Deg.",
    # "Low mV 45 Deg.",
    # "Low mV 90 Deg.",
    # "Natural 0 Deg.",
    # "Natural 22.5 Deg.",
    # "Natural 45 Deg.",
    # "Natural 90 Deg.",
    # "Natural 180 Deg."
  )),
  yvar = "gj",
  colorvals = c(
    "#993404",
    "#993404",
    "#D1416F",
    "#D1416F"
    
    # "#045a8d",
    # "#045a8d",
    # "#045a8d",
    # "#045a8d",
    
    # "#005a32",
    # "#005a32",
    # "#005a32",
    # "#005a32",
    # "#005a32"
  )
)

p2 <- sfn_Rc_ggplot(
  df = filter(d, Condition %in% c(
    # "TEA Mimic Sync",
    # "TEA Mimic Async",
    # "High Amplitude Async",
    # "High Amplitude Async Cd2+",
    "Low mV 0 Deg.",
    "Low mV 22.5 Deg.",
    "Low mV 45 Deg.",
    "Low mV 90 Deg."#,
    # "Natural 0 Deg.",
    # "Natural 22.5 Deg.",
    # "Natural 45 Deg.",
    # "Natural 90 Deg.",
    # "Natural 180 Deg."
  )),
  yvar = "gj",
  colorvals = c(
    # "#993404",
    # "#993404",
    # "#D1416F",
    # "#D1416F",
    
    "#045a8d",
    "#045a8d",
    "#045a8d",
    "#045a8d"
    
    # "#005a32",
    # "#005a32",
    # "#005a32",
    # "#005a32",
    # "#005a32"
  )
)

p3 <- sfn_Rc_ggplot(
  df = filter(d, Condition %in% c(
    # "TEA Mimic Sync",
    # "TEA Mimic Async",
    # "High Amplitude Async",
    # "High Amplitude Async Cd2+",
    # "Low mV 0 Deg.",
    # "Low mV 22.5 Deg.",
    # "Low mV 45 Deg.",
    # "Low mV 90 Deg.",
    "Natural 0 Deg.",
    "Natural 22.5 Deg.",
    "Natural 45 Deg.",
    "Natural 90 Deg.",
    "Natural 180 Deg."
  )),
  yvar = "gj",
  colorvals = c(
    # "#993404",
    # "#993404",
    # "#D1416F",
    # "#D1416F",
    
    # "#045a8d",
    # "#045a8d",
    # "#045a8d",
    # "#045a8d",
    
    "#005a32",
    "#005a32",
    "#005a32",
    "#005a32",
    "#005a32"
    
  )
)


p1/p2/p3

```






## Test w/o deltas
```{r}
# d <- add_stim_delay_phase(d = M)
d <- M

d$inter <- paste0(d$Experiment, ".", d$Inj_Cell)
# REPEAT Manual QC wonky points ----
## gj ====
#TEA sync
d[d$inter == "180212.LC4" & d$Time %in% c(40), "gj"] <- NA
# ps0
d[d$inter == "180507.LC4" & d$Time %in% c(40), "gj"] <- NA
# natural 0
d[d$inter == "170711e.LC4" & d$Time %in% c(20), "gj"] <- NA
d[d$inter == "170814b.LC5" & d$Time %in% c(60), "gj"] <- NA
# natural 22.5
 
#  natural 45
d[d$inter == "170925A.LC5" & d$Time %in% c(20), "gj"] <- NA
d[d$inter == "170925A.LC4" & d$Time %in% c(20, 40), "gj"] <- NA

# natural 90
d[d$inter == "170803a.LC4" & d$Time %in% c(20), "gj"] <- NA

# natural 180
d[d$inter == "170801a.LC5" & d$Time %in% c(20), "gj"] <- NA


## rc ====
d[d$inter == "180507.LC4" & d$Time %in% c(40), "rc"] <- NA
d[d$inter == "181001.LC4" & d$Time %in% c(40, 60), "rc"] <- NA


#natural 22.5
d[d$inter == "180718a.LC5" & d$Time %in% c(20), "rc"] <- NA
# natural 180
d[d$inter == "170801a.LC5" & d$Time %in% c(20), "rc"] <- NA
```

```{r}
# Use expand grid to get a full combination of tests then filter out the ones we don't want. This will let us use one future_map and maybe get faster
comparisons <- c(paste("PS.0.High.Amp", "PS.22.High.Amp", sep = "_"),
                 paste("PS.22.High.Amp", "PS.90.HA", sep = "_"),
                 paste("PS.90.HA", "PS.90.HA.Cd", sep = "_"),
                 paste("PS.0", "PS.22", "PS.45", "PS.90", sep = "_"),
                 paste("PS.0.orig", "PS.22.orig", "PS.45.orig", "PS.90.orig", "PS.180.orig", sep = "_"))

dept.vars <- c("gj",
               "rc",
               "r12",
               "cc",
               "rmp",
               "r11",
               "r1",
               "intercept.peak_htk", 
               "slope.peak_htk", 
               "intercept.end_htk", 
               "slope.end_htk",
               "intercept.peak_a", 
               "slope.peak_a", 
               "intercept.end_a", 
               "slope.end_a"
)

# Set up a df with the inputs I want.
all.tests <- as.data.frame(expand.grid(comparisons, dept.vars))
names(all.tests) <- c("Groups", "DV")

all.tests <- all.tests %>% 
  mutate(Obs.Net = ifelse(DV %in% c("gj", "Rc", "rc", "r12"), T, F)) %>% #NOTE: gj == Rc; gj != rc
  mutate(Model = ifelse(Groups == "PS.90.HA", "dept.var ~ Time", "dept.var ~ Time * Condition")) %>% #TODO switch to a more robust version built on str_split count
  mutate(Random = "~1 | Experiment") 
# %>% 
# mutate(Contrast = ifelse(!(DV %in% c("PS.90.HA")), "dept.var ~ Time * Condition", "dept.var ~ Time"))

# drop Rc and intercept.peak* from the *.orig datasets.
all.tests <- all.tests[!((str_detect(all.tests$Groups, "orig") & (all.tests$DV %in% c("gj", "Rc", "intercept.peak_htk", 
                                                                                      "slope.peak_htk", 
                                                                                      "intercept.end_htk", 
                                                                                      "slope.end_htk",
                                                                                      "intercept.peak_a", 
                                                                                      "slope.peak_a", 
                                                                                      "intercept.end_a", 
                                                                                      "slope.end_a")) )) , ]
# There's no data for htk with cd
all.tests <- all.tests[!((str_detect(all.tests$Groups, "HA.Cd") & (all.tests$DV %in% c("intercept.peak_htk", 
                                                                                       "slope.peak_htk", 
                                                                                       "intercept.end_htk", 
                                                                                       "slope.end_htk",
                                                                                       "intercept.peak_a", 
                                                                                       "slope.peak_a", 
                                                                                       "intercept.end_a", 
                                                                                       "slope.end_a")) )) , ]

#TODO data for ps90 isn't meshed well. There is current data and ionic current data but they are not tidy. 

# TODO allow this when the K current data is in.
# all.tests <- all.tests[!(all.tests$DV %in% c("intercept.peak_htk", "intercept.peak_a")), ]

```


template for one
```{r}

# 
# input.df <- dplyr::filter(d, Condition %in% c(
#   # "TEA Mimic Sync",
#   # "TEA Mimic Async",
#   "High Amplitude Async",
#   "High Amplitude Async Cd2+"#,
#   # "Low mV 0 Deg.",
#   # "Low mV 22.5 Deg.",
#   # "Low mV 45 Deg.",
#   # "Low mV 90 Deg.",
#   # "Natural 0 Deg.",
#   # "Natural 22.5 Deg.",
#   # "Natural 45 Deg.",
#   # "Natural 90 Deg.",
#   # "Natural 180 Deg."
# ))
# 
# 
# input.df$Time <- as.factor(input.df$Time)
# 
# input.df$inter <- as.factor(input.df$inter)
# 
# fm <- nlme::lme(
#   as.formula(gj ~ Condition * Time),
#   random = ~1 | inter,
#   meth
# od = "ML",
#   data = input.df
# )
# anova.lme(fm)

```





```{r}
# Test ----
M.clean <- d #%>% rename(Rc = gj)
```

```{r}
# 
# # For DJS -- there's some weirdness with above plts
# 
# 
# df_sub <- M.clean[M.clean$Condition %in% c("PS.90.HA", "PS.90.HA.Cd"
#                                  ), ] 
# 
# plt <- df_sub %>% ungroup() %>% #group_by(Experiment, Inj_Cell) %>% 
#   
#   ggplot(aes(x = Time, y = gj, color = Experiment, shape = Inj_Cell, group = inter))+
#   lemon::geom_pointline()+
#   geom_point()+
#   facet_grid(.~Condition)
# 
# plt 
# 
# plt2 <- df_sub %>% 
#   dplyr::select(Condition, Experiment, Inj_Cell, Time, gj) %>% 
#   #FIXME does this double break the code for resampling, or did I fdix that?
#   group_by(Condition, Experiment, Inj_Cell, Time) %>%
#   summarise(gj = mean(gj, na.rm = T)) %>% 
#   ungroup() %>% 
#   
#   # mutate(Time = as.character(Time)) %>% 
#   pivot_wider(names_from = Time, values_from = gj) %>% 
#   mutate(`20` = `20` - `0`,
#          `40` = `40` - `0`,
#          `60` = `60` - `0`) %>% 
#   mutate(`0` = 0) %>% 
#   pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "gj") %>% 
#   mutate(inter = paste(Experiment, Inj_Cell, sep = ".")) %>% 
#   ggplot(aes(x = Time, y = gj, color = Experiment, shape = Inj_Cell, group = inter))+
#   lemon::geom_pointline()+
#   geom_point()+
#   facet_grid(.~Condition)+
#   geom_hline(yintercept = 0)
# 
# 
# plt/plt2
# 
# # plotly::ggplotly(plt)
# 
# 
# 
# 
# 
# df_sub %>% dplyr::select(Experiment, Inj_Cell, Time, gj) %>% group_by(Experiment, Inj_Cell) %>% tally()
```

```{r}
## fcns from thesis ====

ready_data_to_test <- function(
  input.df = M.clean ,  # must contain cols: "Condition", "Experiment", "Inj_Cell", "Time", dept.var
  dept.var = "Rc",
  vis.conditions = c("PS.0.High.Amp", "PS.22.High.Amp"),
  use.times = c(0, 20, 40, 60), # Must contain a Time column

  use.pseudorep.diff.tol = T, # Should we get rid of data outside of a difference tolerance
  use.diff.tol = 0.5, # how different is too different? Where do we start culling?

  obs.is.network = T # Set to F for cell specific measurements
){

  # dept.var = "Rc"
  # input.df = M.clean
  # # must contain cols: "Condition", "Experiment", "Inj_Cell", "Time", dept.var
  # vis.conditions = c("PS.0.High.Amp", "PS.22.High.Amp")
  # use.times = c(0, 20, 40, 60) # Must contain a Time column
  #
  # use.pseudorep.diff.tol = T # Should we get rid of data outside of a difference tolerance
  # use.diff.tol = 0.5 # how different is too different? Where do we start culling?
  #
  # obs.is.network = T # Set to F for cell specific measurements


  # Get data ready for tests ====
  input.df <- input.df %>%
    dplyr::filter(Condition %in% vis.conditions) %>%
    dplyr::filter(Time %in% use.times) %>%
    dplyr::select_at(c("Condition", "Experiment", "Inj_Cell", "Time", dept.var))

  # get rid of pseudoreplicates too far from median if user wants
  if (use.pseudorep.diff.tol){
    input.df <- input.df %>%
      retain_closest_pseudoreplicate(
        group.col = "Condition",
        time.col = "Time",
        cell.col = "Inj_Cell",
        data.col = dept.var,
        diff.tol = use.diff.tol)
  }

  # Rename the dependent variable to "dept.var" to make it easy to refer to it no matter what the user put in. At the end we'll change it back to the input.
  names(input.df)[names(input.df) == dept.var] <- "dept.var"

  # Summarize within a cell to rm pseudoreplicates
  input.df <- input.df %>%
    group_by(Condition, Experiment, Time, Inj_Cell) %>%
    summarise(dept.var = median(dept.var, na.rm = T)) %>%
    ungroup()

  # For gap junction measurements we'll have pseudoreplicates from each cell (since we have no evidence for rectification)
  #TODO make a figure like the one I had in comps that showed lack of evidence of rectification
  if (obs.is.network){
    input.df <- input.df %>%
      group_by(Condition, Experiment, Time) %>%
      summarise(dept.var = median(dept.var, na.rm = T)) %>%
      # mutate(Inj_Cell = "LC4") %>% # We're adding back in "Inj_Cell" so that random effects can be based on Experiment_Cell so we don't have to have two versions depending on if the observation is the cell or the network
      ungroup()
  }

  return(input.df)
}



### Rule 1. Points must be within a given similarity tolerance. If the absolute value of pseudoreplicate differences is too great, we will drop the pseudoreplicate that is farther from the rest of the non-zero points.
retain_closest_pseudoreplicate <- function(
  input.df = df,#mutate(df, group.uid = paste(Condition, Experiment, sep = "_"))
  group.col = "Condition",
  time.col = "Time",
  cell.col = "Inj_Cell",
  data.col = "Rc",
  diff.tol = 0.5){
  if (length(unique(input.df[[cell.col]])) != 2){
    warning("There are not exactly 2 types of cells. Did this data pass QC or are there missing labels?")
    
    
  } else {
    
    cell.types <- unique(input.df[[cell.col]])
    
    
    # NAs can cause pivot_wider to choke. 
    input.df <- input.df[!is.na(input.df[[data.col]]), ]
    # Put data in a format which makes it easy to get difference
    input.df <- input.df %>% 
      ungroup() %>% 
      pivot_wider(names_from = cell.col, values_from = data.col)
    
    # get the absolute difference
    input.df$difference <- abs(input.df[[as.character(cell.types[1])]] - input.df[[as.character(cell.types[2])]])
    
    # flag those exceeding the tolerance
    input.df <- input.df %>% 
      dplyr::mutate(too.different = ifelse(difference > diff.tol, T, F))
    
    # for those exceeding tolerance
    problems.df <- input.df %>% filter(too.different == T)
    
    problems.df <- input.df %>% 
      filter(too.different == T) %>% # Only use the data we need to check
      pivot_longer(cols = cell.types,  names_to = cell.col, values_to = data.col) %>% 
      group_by_at(vars(group.col, time.col)) %>% #Note this works but group_by CRASHES AND BURNS when you try to use strings. There may be a work around by transforming a string into a quosure but my standard set of tricks for passing strings into dplyr verbs didn't work. ¯\_(ツ)_/¯
      
      group_by_at(vars(all_of(group.col), all_of(time.col))) %>% # to get rid of warnings re external vectors I've changed the above to this. 
      # This is an example of the error
      # Note: Using an external vector in selections is ambiguous.
      # i Use `all_of(cell.types)` instead of `cell.types` to silence this message.
      
      summarise(group.median = median(!!as.name(data.col), na.rm = T))
    
    input.df <- full_join(input.df, problems.df) %>% 
      mutate(group.median = ifelse(too.different, group.median, NA)) %>% # Overwrite group medians (with NA) where we don't have a big enough differnece to evaluate which to discard.
      mutate(discard.which = ifelse(abs(group.median - !!as.name(cell.types[1])) < abs(group.median - !!as.name(cell.types[2])), cell.types[2], cell.types[1] )) # figure out which has the highest residual from the median
    
    # Overwrite the to discard observations with NAs.
    input.df[input.df$discard.which == cell.types[1] & !is.na(input.df$discard.which), cell.types[1]] <- NA
    input.df[input.df$discard.which == cell.types[2] & !is.na(input.df$discard.which), cell.types[2]] <- NA
    
    # Discard the columns we added
    input.df <- input.df %>% dplyr::select(-c("difference", "too.different", "group.median", "discard.which"))
    
    # Reshape back to longer
    input.df <- input.df %>% pivot_longer(cols = cell.types,  names_to = cell.col, values_to = data.col)
    
    # Return input.df
    return(input.df)
  }  
}
```

# Refactored resampling 
```{r eval=FALSE, include=FALSE}

# WARNING
# Close everything else before running this bit!
# Running required ~ 11GB ram for 1000 resamplings


## Make counterfactual dfs and run tests ====
if (make.resample.results){
  set.seed(657984118)
  
## split all.tests up into a list of dfs ====
all.tests.list <- map(1:nrow(all.tests), function(i){
  all.tests[i, ]
})

## pull out the relevant data to shuffle ====
prepped.df <- furrr::future_map(seq_along(all.tests.list), 
                                function(i, 
                                         in.data = M.clean){
                                  
                                  test.info <- all.tests.list[[i]]
                                  
                                  data.slice <- ready_data_to_test(
                                    input.df = in.data,
                                    dept.var = as.character(test.info[, "DV"]),
                                    vis.conditions = str_split(string = as.character(test.info[, "Groups"]), pattern = "_")[[1]], # Split up char string.
                                    use.times = c(0, 20, 40, 60),
                                    use.pseudorep.diff.tol = T,
                                    use.diff.tol = 0.5,
                                    obs.is.network = as.logical(test.info[, "Obs.Net"]))
                                  
                                  
                                })

## Make up all the datasets to be used ====
# The first one is the actual data
df_and_counterfactual <- furrr::future_map(prepped.df, 
                                           function(inputdf, 
                                                    iterations = resample.nreps
                                           ){
                                             furrr::future_map(seq(1, iterations), function(
                                               i
                                             ){
                                               if (i == 1) {
                                                 return(inputdf)
                                               } else {
                                                 mutate(inputdf,
                                                        dept.var = sample(unlist(dplyr::select_at(inputdf, "dept.var")),
                                                                          replace = T
                                                        )
                                                 )
                                               }
                                             })
                                           })

## Apply the proscribed stats test ====
nested_test_results <- furrr::future_map(seq_along(df_and_counterfactual), 
                                         function(i){
                                           
                                           df.list <- df_and_counterfactual[[i]]
                                           
                                           df.main.formula <- as.formula(all.tests[i, "Model"])
                                           df.rand.formula <- as.formula(all.tests[i, "Random"])
                                           
                                           furrr::future_map(df.list, function(df, main.formula = df.main.formula, rand.formula = df.rand.formula){
                                             
                                             # get rid of NA in DV ----
                                             input.df <- df[!is.na(df$dept.var), ]
                                             
                                             # test ----
                                             # In some situations this will fail with  "Error in MEEM(object, conLin, control$niterEM) : \n  Singularity in backsolve at level 0, block 1\n"
                                             
                                             # the result of nlme will be a list unless there was an error in which case it will be a character type
                                             # if fm is a character type then we'll make a new random df on the fly UNLESS j = 1 in which case we'll provide an error message
                                             
                                             fm <- try(nlme::lme(
                                               main.formula,
                                               # dept.var ~ Time * Condition,
                                               random = rand.formula,
                                               # random = ~1 | Experiment,
                                               method = "REML",
                                               data = input.df
                                             ))
                                             
                                             # make up replacement value on the fly. ----
                                             if (typeof(fm) == "character") {
                                               if (j == 1) {
                                                 warning("\n\nThe input data produced an error. 
                \nIt could not be fit by nlme::lme() 
                \nConsider fitting it manually before trying again.")
                                               } else {
                                                 counter <- 1
                                                 while (counter > 100 & typeof(fm) == "character") {
                                                   input.df <- mutate(preped.df,
                                                                      dept.var = sample(unlist(dplyr::select_at(preped.df, "dept.var")),
                                                                                        replace = T
                                                                      )
                                                   )
                                                   
                                                   fm <- try(nlme::lme(
                                                     as.formula(all.tests[i, "Model"]),
                                                     # dept.var ~ Time * Condition,
                                                     random = as.formula(all.tests[i, "Random"]),
                                                     # random = ~1 | Experiment,
                                                     method = "REML",
                                                     data = input.df
                                                   ))
                                                 }
                                               }
                                               
                                             }
                                             
                                             return(fm)
                                           })
                                         }) 


## Make tables of asymptotic test statistics ====
asymptotic_res <- furrr::future_map(nested_test_results, function(test_set){
  anova.lme(test_set[[1]])
})

## Make tables of empirical test statistics ====

### get all the f values in a single df for each test ####
resampled_distribution <- furrr::future_map(nested_test_results, function(test_set){
  # test_set <- nested_test_results[[1]]
  
  
  #Debugging. Error in solving produced an error here.
  # for (i in seq_along(nested_test_results)){
  #   for (j in 1:1000){
  #     
  #     i = 39
  #     j = 72
  #     
  #     fm <- nested_test_results[[i]][[j]]
  #     typeof(fm)
  #     
  #     out2 <- try(anova.lme(fm))[, "F-value"]
  #     
  #     print(paste(as.character(i), "|", as.character(j)))
  #     print(out2)
  #   }
  # }
  
  
  # join into dataframe (asymptotic == row 1)
  fvals <- furrr::future_map(test_set, function(fm){
    # if there was an error in solving, e.g. Singularity in backsolve at level 0, we want to drop this value.
    if (typeof(fm) == "character"){
      table <- NA
    } else {
      table <- try(anova.lme(fm))[, "F-value"]      
    }
    return(table)
  })
  
  fvals <- fvals %>% 
    reduce(rbind) %>% 
    as.data.frame()
  
  # if there were any errors there will be a blank in the dataframe. Drop it.
  fvals <- fvals[!is.na(fvals$V1), ]
  
  # apply appropriate labels
  names(fvals) <- anova.lme(test_set[[1]]) %>% rownames()
  
  return(fvals)
})

### convert into empirical p values ####
resampled_pvals <- furrr::future_map(resampled_distribution, function(resampled_f){
  pvals <- resampled_f[1, ]
  
  for (i in seq(1, ncol(pvals))){
    pvals[1, i] <- mean(resampled_f[1, i] <= resampled_f[, i])
    
  }
  
  return(pvals)
})

### Add resampled p values to asymptotic
asymp_resamp_stats <- furrr::future_map(seq_along(asymptotic_res), function(i){
  
  table <- asymptotic_res[[i]]
  resampled_p <- resampled_pvals[[i]]
    
  table$`ep-value` <- NA
  table$`ep-value` <- as.vector(t(resampled_p))
  
  return(table)
})

### Add annotations
asymp_resamp_stats_annotated <- furrr::future_map(seq_along(asymp_resamp_stats), function(i){
  
  temp <- asymp_resamp_stats[[i]]
  
  temp$parameter <- rownames(temp)
  temp$response <- all.tests[i, "DV"]
  temp$groups <- all.tests[i, "Groups"]
  
  # if it's class anova.lme then selection with new cols causes it to choke.
  temp <- as.data.frame(temp)
  # re order to make sorting easier
  temp <- temp[, c(7:8, 6,1:5)]
  
  return(temp)
  
})

### Make summary stats table 
all_stats <- do.call(rbind, asymp_resamp_stats_annotated)
}


### Make paramter estimates and summary table 
param_estimates <- map(seq_along(nested_test_results), function(i){
  fm <- nested_test_results[[i]][[1]]
  params <- tidy(fm)
  # params <- tidy(test.results[[i]]$res[[1]])
  params <- params %>% dplyr::select(term, estimate) %>% filter(term != "(Intercept)") %>% distinct() %>% rename(Term = term)
  params <- rbind(data.frame(Term = c("(Intercept)"), estimate = c(NA)),
                  params)
  
  params <- params %>% mutate(
    DV = all.tests[i, "DV"],
    Groups = all.tests[i, "Groups"])
  
  params <- params[, c("DV", "Groups", "Term", "estimate")]
})

all_param_estimates <- do.call(rbind, param_estimates)

## Cache all Resampling objects ====
if (save.resample.results){
  saveRDS(object = all.tests.list, file = here("data", "resampling_cache", "all.tests.list.rds"))
  saveRDS(object = prepped.df, file = here("data", "resampling_cache", "prepped.df.rds"))
  saveRDS(object = df_and_counterfactual, file = here("data", "resampling_cache", "df_and_counterfactual.rds"))
  saveRDS(object = nested_test_results, file = here("data", "resampling_cache", "nested_test_results.rds"))
  saveRDS(object = asymptotic_res, file = here("data", "resampling_cache", "asymptotic_res.rds"))
  saveRDS(object = resampled_distribution, file = here("data", "resampling_cache", "resampled_distribution.rds"))
  saveRDS(object = resampled_pvals, file = here("data", "resampling_cache", "resampled_pvals.rds"))
  saveRDS(object = asymp_resamp_stats, file = here("data", "resampling_cache", "asymp_resamp_stats.rds"))
  saveRDS(object = all_stats, file = here("data", "resampling_cache", "all_stats.rds"))
}

## Write out tables ====
if (write.resample.results){
  write.csv(all_param_estimates, file = here("data", "stats", "all_param_estimates.csv"))
  
  write.csv(all_stats, file = here("data", "stats", "all_stats.csv"), row.names = F)
  
  walk(asymp_resamp_stats_annotated, function(df){
    
    file.name <- paste(
      as.character(df[1, "response"]), 
      "-",
      as.character(df[1, "groups"]),
      ".csv",
      sep = "")  
    
    write.csv(df, file = here("data", "stats", file.name), row.names = F)
  })
  
  
}

## Load all Resampling objects ====
if (load.resample.results){
  all.tests.list <- readRDS(file = here("data", "resampling_cache", "all.tests.list.rds"))
  prepped.df <- readRDS(file = here("data", "resampling_cache", "prepped.df.rds"))
  df_and_counterfactual <- readRDS(file = here("data", "resampling_cache", "df_and_counterfactual.rds"))
  nested_test_results <- readRDS(file = here("data", "resampling_cache", "nested_test_results.rds"))
  asymptotic_res <- readRDS(file = here("data", "resampling_cache", "asymptotic_res.rds"))
  resampled_distribution <- readRDS(file = here("data", "resampling_cache", "resampled_distribution.rds"))
  resampled_pvals <- readRDS(file = here("data", "resampling_cache", "resampled_pvals.rds"))
  asymp_resamp_stats <- readRDS(file = here("data", "resampling_cache", "asymp_resamp_stats.rds"))
  all_stats <- readRDS(file = here("data", "resampling_cache", "all_stats.rds"))
}
```

### Get test results from asymptotic tests for jneurosci.

```{r eval=FALSE, include=FALSE}
all.tests.list <- readRDS(here("data", "resampling_cache", "all.tests.list.rds"))

asymptotic_res <- readRDS(here("data", "resampling_cache", "asymptotic_res.rds"))

test.info.for.jneurosci <- map(seq_along(all.tests.list), function(i){
  temp.metadata <- all.tests.list[[i]]
  temp <- asymptotic_res[[i]]
  
  temp$Parameter <- rownames(temp)
  temp <- temp[, c("Parameter", names(temp)[names(temp) != "Parameter"])]
  
  temp <- cbind(temp.metadata, temp)
  
  return(temp)
})

write.csv(do.call(rbind, test.info.for.jneurosci), file = here("data", "stats", "all_asymp_details_for_jneurosci.csv"))


```

## serial resampling
```{r eval=FALSE, include=FALSE}
# tic <- Sys.time()
# 
# ## Make counterfactual dfs and run tests ====
# if (make.resample.results){
#   set.seed(657984118)
#   
# ## split all.tests up into a list of dfs ====
# all.tests.list <- map(1:nrow(all.tests), function(i){
#   all.tests[i, ]
# })
# 
# 
# ## pull out the relevant data to shuffle ====
# prepped.df <- furrr::future_map(seq_along(all.tests.list), 
#                                 function(i, 
#                                          in.data = M.clean){
#                                   
#                                   test.info <- all.tests.list[[i]]
#                                   
#                                   data.slice <- ready_data_to_test(input.df = in.data,
#                                                                    dept.var = as.character(test.info[, "DV"]),
#                                                                    vis.conditions = str_split(string = as.character(test.info[, "Groups"]), pattern = "_")[[1]], # Split up char string.
#                                                                    use.times = c(0, 20, 40, 60),
#                                                                    use.pseudorep.diff.tol = T,
#                                                                    use.diff.tol = 0.5,
#                                                                    obs.is.network = as.logical(test.info[, "Obs.Net"]))
#                                   
#                                   
#                                 })
# 
# stats.res.list <- furrr::future_map(seq_along(all.tests.list), function(i, nreps = resample.nreps){
# current.test = all.tests.list[[i]]
# input.df = prepped.df[[i]]
#   
# main.formula <- as.formula(current.test[, "Model"])
# rand.formula <- as.formula(current.test[, "Random"])
# 
# resampled.res <- furrr::future_map(seq(1, nreps+1), function(j, df = input.df){
#   # each iteration
#   if (j == 1){
#     # df <- df
#   } else {
#     df <- mutate(df, dept.var = sample(unlist(dplyr::select_at(df, "dept.var")), replace = T))
#   }
#   
#   # get rid of NA in DV ----
#   input.df <- df[!is.na(df$dept.var), ]
#   
#   # test ----
#   # In some situations this will fail with  "Error in MEEM(object, conLin, control$niterEM) : \n  Singularity in backsolve at level 0, block 1\n"
#   
#   # the result of nlme will be a list unless there was an error in which case it will be a character type
#   # if fm is a character type then we'll make a new random df on the fly UNLESS j = 1 in which case we'll provide an error message
#   
#   fm <- try(nlme::lme(
#     main.formula,
#     # dept.var ~ Time * Condition,
#     random = rand.formula,
#     # random = ~1 | Experiment,
#     method = "REML",
#     data = input.df
#   ))
#   
#   # make up replacement value on the fly. ----
#   if (typeof(fm) == "character") {
#     if (j == 1) {
#       warning("\n\nThe input data produced an error. 
#                 \nIt could not be fit by nlme::lme() 
#                 \nConsider fitting it manually before trying again.")
#     } else {
#       counter <- 1
#       while (counter > 100 & typeof(fm) == "character") {
#         input.df <- mutate(preped.df,
#                            dept.var = sample(unlist(dplyr::select_at(preped.df, "dept.var")),
#                                              replace = T
#                            )
#         )
#         
#         fm <- try(nlme::lme(
#           as.formula(all.tests[i, "Model"]),
#           # dept.var ~ Time * Condition,
#           random = as.formula(all.tests[i, "Random"]),
#           # random = ~1 | Experiment,
#           method = "REML",
#           data = input.df
#         ))
#       }
#     }
#     
#   }
#   
#   results.tab <- anova.lme(fm)
#   
#   estimates <- broom::tidy(fm) %>% filter(term != "(Intercept)") %>% dplyr::select(term, estimate) %>% distinct() %>% spread(term, estimate)
#   
#   output <- cbind(cbind(as.data.frame(rownames(results.tab)), results.tab), estimates)
#   names(output)[1] <- "Parameter"
#   output$j <- j
#   
#   return(output)
# })
# 
# resampled.res2 <- do.call(rbind, resampled.res)
# 
# # Trim down to useful statistics
# obs.f <- resampled.res2[resampled.res2$j == 1 , "F-value"]
# resampled.res2$`Obs-F` <- rep(obs.f, times = nrow(resampled.res2)/length(obs.f) )
# resampled.res2 <- resampled.res2 %>% group_by(Parameter) %>% mutate(Extreme = `F-value` >= `Obs-F`) %>% mutate(`ep-value` = mean(Extreme, na.rm = T)) %>% dplyr::filter(j == 1)
# 
# resampled.res2 <- resampled.res2 %>%  dplyr::select(-Extreme) %>% dplyr::select(-`Obs-F`) %>% dplyr::select(-j)
# 
# resampled.res2$Groups <- current.test[, "Groups"]
# resampled.res2$DV <- current.test[, "DV"]
# 
# return(resampled.res2)
# 
# })
# 
# # bind
# stats.res.df <- stats.res.list[[1]]
# for (i in seq(2, length(stats.res.list) ) ){
#   stats.res.df <- full_join(stats.res.df, stats.res.list[[i]])
# }
# 
# write.csv(stats.res.df, file = here("data", "stats", "allresampledstats.csv"))
# write.csv(stats.res.df, file = here("data", "stats", "allresampledstats_10k.csv"))
# }
# 
# toc <- Sys.time()
# print(toc - tic)
```


```{r eval=FALSE, include=FALSE}
# The above section was failing at higher (10 000) reps. 
## Make counterfactual dfs and run tests ====
# if (make.resample.results){
# tic <- Sys.time()


set.seed(657984118)

## split all.tests up into a list of dfs ====
all.tests.list <- map(1:nrow(all.tests), function(i){
  all.tests[i, ]
})
## pull out the relevant data to shuffle ====
prepped.df <- furrr::future_map(seq_along(all.tests.list), 
                                function(i, 
                                         in.data = M.clean){
                                  
                                  test.info <- all.tests.list[[i]]
                                  
                                  data.slice <- ready_data_to_test(input.df = in.data,
                                                                   dept.var = as.character(test.info[, "DV"]),
                                                                   vis.conditions = str_split(string = as.character(test.info[, "Groups"]), pattern = "_")[[1]], # Split up char string.
                                                                   use.times = c(0, 20, 40, 60),
                                                                   use.pseudorep.diff.tol = T,
                                                                   use.diff.tol = 0.5,
                                                                   obs.is.network = as.logical(test.info[, "Obs.Net"]))
                                  
                                  
                                })




## Shuffle, test, repeat ====
# This portion I've changed to overcome an error in the fitting preventing the tests that are completed from being saved.
stats.res.list <- list(length = length(all.tests.list))

tictoc::tic()
for (i in seq_along(all.tests.list)){
  tic <- Sys.time() 
  
  current.test = all.tests.list[[i]]
  input.df = prepped.df[[i]]
  main.formula <- as.formula(current.test[, "Model"])
  rand.formula <- as.formula(current.test[, "Random"])
  
  nreps <- resample.nreps
  
  resampled.res <- furrr::future_map(seq(1, nreps+1), function(j, df = input.df){
    
    output <- NA
    
    # j = 1
    # df = input.df
    # j = 2
    # df = input.df
    
    # each iteration
    if (j == 1){
      # df <- df
    } else {
      df <- mutate(df, dept.var = sample(unlist(dplyr::select_at(df, "dept.var")), replace = T))
    }
    
    # get rid of NA in DV ----
    input.df <- df[!is.na(df$dept.var), ]
    
    # the result of nlme will be a list unless there was an error in which case it will be a character type
    # if fm is a character type then we'll make a new random df on the fly UNLESS j = 1 in which case we'll provide an error message
    
    fm <- try(nlme::lme(
      main.formula,
      # dept.var ~ Time * Condition,
      random = rand.formula,
      # random = ~1 | Experiment,
      method = "REML",
      data = input.df
    ))
    
    # make up replacement value on the fly. ----
    if (typeof(fm) == "character") {
      if (j == 1) {
        warning("\n\nThe input data produced an error. 
                \nIt could not be fit by nlme::lme() 
                \nConsider fitting it manually before trying again.")
      } else {
        counter <- 1
        while (counter > 100 & typeof(fm) == "character") {
          input.df <- mutate(preped.df,
                             dept.var = sample(unlist(dplyr::select_at(preped.df, "dept.var")),
                                               replace = T
                             )
          )
          
          fm <- try(nlme::lme(
            as.formula(all.tests[i, "Model"]),
            # dept.var ~ Time * Condition,
            random = as.formula(all.tests[i, "Random"]),
            # random = ~1 | Experiment,
            method = "REML",
            data = input.df
          ))
        }
      }
      
    }
    
    
    if (typeof(fm) == "list"){
      results.tab <- anova.lme(fm)
    
    estimates <- broom::tidy(fm) %>% filter(term != "(Intercept)") %>% dplyr::select(term, estimate) %>% distinct() %>% spread(term, estimate)
    
    output <- cbind(cbind(as.data.frame(rownames(results.tab)), results.tab), estimates)
    names(output)[1] <- "Parameter"
    output$j <- j
    } 
    
    
    return(output)
  })
  
  resampled.res2 <- do.call(rbind, resampled.res)
  # Trim down to useful statistics
  obs.f <- resampled.res2[resampled.res2$j == 1 , "F-value"]
  resampled.res2$`Obs-F` <- rep(obs.f, times = nrow(resampled.res2)/length(obs.f) )
  resampled.res2 <- resampled.res2 %>% group_by(Parameter) %>% mutate(Extreme = `F-value` >= `Obs-F`) %>% mutate(`ep-value` = mean(Extreme, na.rm = T)) %>% dplyr::filter(j == 1)
  resampled.res2 <- resampled.res2 %>%  dplyr::select(-Extreme) %>% dplyr::select(-`Obs-F`) %>% dplyr::select(-j)
  resampled.res2$Groups <- current.test[, "Groups"]
  resampled.res2$DV <- current.test[, "DV"]
  
  stats.res.list[[i]] <- resampled.res2
  
  # added for debugging
  names(stats.res.df)[i] <- as.character(i)
  
  
  code_duration <- Sys.time() - tic
  print(
    paste(
      as.character(round(code_duration, digits = 1)),
      "Seconds Elapsed",
      as.character(round((length(all.tests.list) - 1) * (code_duration)/60, digits = 1)),
      "Minutes Remaining"
      )
    )
}
tictoc::toc()


# stats.res.list <- furrr::future_map(seq_along(all.tests.list), function(i, nreps = resample.nreps){
#   # current.test = all.tests.list[[i]]
#   # input.df = prepped.df[[i]]
#   # 
#   # main.formula <- as.formula(current.test[, "Model"])
#   # rand.formula <- as.formula(current.test[, "Random"])
#   
#   # resampled.res <- furrr::future_map(seq(1, nreps+1), function(j, df = input.df){
#   #   # each iteration
#   #   if (j == 1){
#   #     # df <- df
#   #   } else {
#   #     df <- mutate(df, dept.var = sample(unlist(dplyr::select_at(df, "dept.var")), replace = T))
#   #   }
#   #   
#   #   # get rid of NA in DV ----
#   #   input.df <- df[!is.na(df$dept.var), ]
#   #   
#   #   # the result of nlme will be a list unless there was an error in which case it will be a character type
#   #   # if fm is a character type then we'll make a new random df on the fly UNLESS j = 1 in which case we'll provide an error message
#   #   
#   #   fm <- try(nlme::lme(
#   #     main.formula,
#   #     # dept.var ~ Time * Condition,
#   #     random = rand.formula,
#   #     # random = ~1 | Experiment,
#   #     method = "REML",
#   #     data = input.df
#   #   ))
#   #   
#   #   # make up replacement value on the fly. ----
#   #   if (typeof(fm) == "character") {
#   #     if (j == 1) {
#   #       warning("\n\nThe input data produced an error. 
#   #               \nIt could not be fit by nlme::lme() 
#   #               \nConsider fitting it manually before trying again.")
#   #     } else {
#   #       counter <- 1
#   #       while (counter > 100 & typeof(fm) == "character") {
#   #         input.df <- mutate(preped.df,
#   #                            dept.var = sample(unlist(dplyr::select_at(preped.df, "dept.var")),
#   #                                              replace = T
#   #                            )
#   #         )
#   #         
#   #         fm <- try(nlme::lme(
#   #           as.formula(all.tests[i, "Model"]),
#   #           # dept.var ~ Time * Condition,
#   #           random = as.formula(all.tests[i, "Random"]),
#   #           # random = ~1 | Experiment,
#   #           method = "REML",
#   #           data = input.df
#   #         ))
#   #       }
#   #     }
#   #     
#   #   }
#   #   
#   #   results.tab <- anova.lme(fm)
#   #   
#   #   estimates <- broom::tidy(fm) %>% filter(term != "(Intercept)") %>% dplyr::select(term, estimate) %>% distinct() %>% spread(term, estimate)
#   #   
#   #   output <- cbind(cbind(as.data.frame(rownames(results.tab)), results.tab), estimates)
#   #   names(output)[1] <- "Parameter"
#   #   output$j <- j
#   #   
#   #   return(output)
#   # })
#   
#   resampled.res2 <- do.call(rbind, resampled.res)
#   
#   # Trim down to useful statistics
#   obs.f <- resampled.res2[resampled.res2$j == 1 , "F-value"]
#   resampled.res2$`Obs-F` <- rep(obs.f, times = nrow(resampled.res2)/length(obs.f) )
#   resampled.res2 <- resampled.res2 %>% group_by(Parameter) %>% mutate(Extreme = `F-value` >= `Obs-F`) %>% mutate(`ep-value` = mean(Extreme, na.rm = T)) %>% dplyr::filter(j == 1)
#   
#   resampled.res2 <- resampled.res2 %>%  dplyr::select(-Extreme) %>% dplyr::select(-`Obs-F`) %>% dplyr::select(-j)
#   
#   resampled.res2$Groups <- current.test[, "Groups"]
#   resampled.res2$DV <- current.test[, "DV"]
#   
#   return(resampled.res2)
#   
# })




####

# bind
stats.res.df <- stats.res.list[[1]]
for (i in seq(2, length(stats.res.list) ) ){
  stats.res.df <- full_join(stats.res.df, stats.res.list[[i]])
}

# write.csv(stats.res.df, file = here("data", "stats", "allresampledstats.csv"))
write.csv(stats.res.df, file = here("data", "stats", "allresampledstats_10k.csv"))
# }
# 
# toc <- Sys.time()
# print(toc - tic)
```

### run
```{r eval=FALSE, include=FALSE}
# The above section was failing at higher (10 000) reps. 
## Make counterfactual dfs and run tests ====
# if (make.resample.results){
# only 2558.43 seconds, 42 minutes to run?
set.seed(657984118)

## split all.tests up into a list of dfs ====
all.tests.list <- map(1:nrow(all.tests), function(i){
  all.tests[i, ]
})
## pull out the relevant data to shuffle ====
prepped.df <- furrr::future_map(seq_along(all.tests.list), 
                                function(i, 
                                         in.data = M.clean){
                                  
                                  test.info <- all.tests.list[[i]]
                                  
                                  data.slice <- ready_data_to_test(input.df = in.data,
                                                                   dept.var = as.character(test.info[, "DV"]),
                                                                   vis.conditions = str_split(string = as.character(test.info[, "Groups"]), pattern = "_")[[1]], # Split up char string.
                                                                   use.times = c(0, 20, 40, 60),
                                                                   use.pseudorep.diff.tol = T,
                                                                   use.diff.tol = 0.5,
                                                                   obs.is.network = as.logical(test.info[, "Obs.Net"]))
                                  
                                  
                                })

## Get asymptotic test results ====
stats.res.list <- list(length = length(all.tests.list))

for (i in seq_along(all.tests.list)){
  current.test = all.tests.list[[i]]
  input.df = prepped.df[[i]]
  main.formula <- as.formula(current.test[, "Model"])
  rand.formula <- as.formula(current.test[, "Random"])
  
  output <- NA
  
  # get rid of NA in DV ----
  input.df <- input.df[!is.na(input.df$dept.var), ]
  
  # the result of nlme will be a list unless there was an error in which case it will be a character type
  # if fm is a character type then we'll make a new random df on the fly UNLESS j = 1 in which case we'll provide an error message
  
  fm <- try(nlme::lme(
    main.formula,
    # dept.var ~ Time * Condition,
    random = rand.formula,
    # random = ~1 | Experiment,
    method = "REML",
    data = input.df
  ))
  
  
  if (typeof(fm) == "list"){
    results.tab <- anova.lme(fm)
    
    estimates <- broom::tidy(fm) %>% filter(term != "(Intercept)") %>% dplyr::select(term, estimate) %>% distinct() %>% spread(term, estimate)
    
    output <- cbind(cbind(as.data.frame(rownames(results.tab)), results.tab), estimates)
    names(output)[1] <- "Parameter"
    
    output$Groups <- current.test[, "Groups"]
    output$DV <- current.test[, "DV"]
    
  } 

  stats.res.list[[i]] <- output
}

## Add in empirical results ====
# This portion I've changed to overcome an error in the fitting preventing the tests that are completed from being saved.


tictoc::tic()
for (i in seq_along(all.tests.list)){
  tic <- Sys.time() 
  
  current.test = all.tests.list[[i]]
  input.df = prepped.df[[i]]
  main.formula <- as.formula(current.test[, "Model"])
  rand.formula <- as.formula(current.test[, "Random"])
  
  asymp.Fs <- stats.res.list[[i]][, "F-value"]
  
  nreps <- resample.nreps
  
  resampled.res <- furrr::future_map(seq(1, nreps), function(j, df = input.df){
    output <- NA
    # each iteration
    df <- mutate(df, dept.var = sample(unlist(dplyr::select_at(df, "dept.var")), replace = T))
    input.df <- df[!is.na(df$dept.var), ]
    # the result of nlme will be a list unless there was an error in which case it will be a character type
    # if fm is a character type then we'll make a new random df on the fly UNLESS j = 1 in which case we'll provide an error message
    
    fm <- try(nlme::lme(
      main.formula,
      # dept.var ~ Time * Condition,
      random = rand.formula,
      # random = ~1 | Experiment,
      method = "REML",
      data = input.df
    ))
    # if there's an error we must make up replacement value on the fly. ----
    counter <- 1
    while (counter > 100 & typeof(fm) == "character") {
      input.df <- mutate(preped.df,
                         dept.var = sample(unlist(dplyr::select_at(preped.df, "dept.var")),
                                           replace = T
                         )
                         
      )
      input.df <- df[!is.na(df$dept.var), ]
      
      fm <- try(nlme::lme(
        as.formula(all.tests[i, "Model"]),
        # dept.var ~ Time * Condition,
        random = as.formula(all.tests[i, "Random"]),
        # random = ~1 | Experiment,
        method = "REML",
        data = input.df
      ))
    }
    
     
    if (typeof(fm) == "list"){
    results.tab <- anova.lme(fm)
    
    
    
    output <- data.frame(Parameter = rownames(results.tab),
               Obs.Greater = asymp.Fs >= results.tab$`F-value`,
               j = j)
        return(output)
    } else {
      warning(paste("Resampling iteration", as.character(j), "returned no output."))
      return(NA)
    }
    

  })
  
  resampled.res <- do.call(rbind, resampled.res)
  # resampled.res <- resampled.res %>% pivot_wider(names_from = "Parameter", values_from = "Obs.Greater") %>% summarise()
  
  resampled.res <-  resampled.res %>% 
    group_by(Parameter) %>% 
    mutate(`ep-value` = (sum(Obs.Greater)+1) / (nreps+1)) %>%  # adding one accounts for the asymptotic result
    dplyr::select("Parameter", "ep-value") %>% 
    distinct()
  
  
  stats.res.list[[i]] <-   full_join(stats.res.list[[i]], resampled.res, by = "Parameter")
  
  code_duration <- Sys.time() - tic
  print(
    paste(
      as.character(round(code_duration, digits = 1)),
      "Seconds Elapsed",
      as.character(round((length(all.tests.list) - 1) * (code_duration)/60, digits = 1)),
      "Minutes Remaining"
      )
    )
}
tictoc::toc()







####

# bind
stats.res.df <- stats.res.list[[1]]
for (i in seq(2, length(stats.res.list) ) ){
  stats.res.df <- full_join(stats.res.df, stats.res.list[[i]])
}

# write.csv(stats.res.df, file = here("data", "stats", "allresampledstats.csv"))
# write.csv(stats.res.df, file = here("data", "stats", "allresampledstats_10k.csv"))

# }
# 
# toc <- Sys.time()
# print(toc - tic)


```




#### Additional tests go here to get added to the end of the test csv
```{reval=FALSE, include=FALSE}
# Cd2.at.40.test.df <- 
# M.clean[M.clean$Condition %in% c(#"PS.90.HA", 
#   "PS.90.HA.Cd" ), ] %>% 
#   dplyr::select(Condition, Experiment, Inj_Cell, Time, gj) %>% 
#   group_by(Condition, Experiment, Inj_Cell, Time) %>%
#   summarise(gj = mean(gj, na.rm = T)) %>% 
#   ungroup() %>% 
#   # mutate(Time = as.character(Time)) %>% 
#   pivot_wider(names_from = Time, values_from = gj) %>% 
#   mutate(`20` = `20` - `0`,
#          `40` = `40` - `0`,
#          `60` = `60` - `0`) %>% 
#   mutate(`0` = 0) %>% 
#   pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "gj") %>% 
#   group_by(Condition, Experiment, Time) %>% 
#   summarise(gj = mean(gj, na.rm = T))
# 
# Cd2.at.40.test.fm <- lm(gj ~ Time, data = Cd2.at.40.test.df[Cd2.at.40.test.df$Time %in% c(0, 40) , ])
# 
# summary(Cd2.at.40.test.fm)


# library(equivalence)

Cd2.tost.df <- M.clean[M.clean$Condition %in% c(#"PS.90.HA", 
  "PS.90.HA.Cd" ), ] %>% 
  dplyr::select(Condition, Experiment, Inj_Cell, Time, gj) %>% 
  group_by(Condition, Experiment, Inj_Cell, Time) %>%
  summarise(gj = mean(gj, na.rm = T)) %>% 
  ungroup() %>% 
  # mutate(Time = as.character(Time)) %>% 
  # pivot_wider(names_from = Time, values_from = gj) %>% 
  # mutate(`20` = `20` - `0`,
  #        `40` = `40` - `0`,
  #        `60` = `60` - `0`) %>% 
  # mutate(`0` = 0) %>% 
  # pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "gj") %>% 
  group_by(Condition, Experiment, Time) %>% 
  summarise(gj = mean(gj, na.rm = T)) %>% 
  pivot_wider(names_from = Time, values_from = gj)

Cd2.tost.fm <- tost(Cd2.tost.df$`0`, Cd2.tost.df$`40`, epsilon = 1, paired = T, var.equal = T, conf.level = 0.95)


round.to = 3

Cd2.tost.stat <- data.frame(
  Journal = 
    paste0(
      # "(",
      #      "rIg",
           ", ",
           "0 vs 40 minutes",
           ", ",
           
           "df = ",
           as.character(Cd2.tost.fm$parameter), 
           
           ", p = ",
           as.character(round(Cd2.tost.fm$tost.p.value , digits = round.to) ), 
           ", Paired TOST)"),
  Groups = "PS.90.HA_PS.90.HA.Cd",
  DV = "gj",
  DVPrint = c("gj-1"),
  Txt_Raw = c("g"),
  Txt_SScript1 = c("j"),
  Txt_SScript2 = c("-1")
)

# "Journal", "Groups", "DV", "Parameter", "numDF", "denDF", "pValue", "epValue", "DVPrint"



# stats.res.df$Journal <- paste0("(",
#                                as.character(stats.res.df$DVPrint),
#                                " ",
#                                as.character(stats.res.df$Parameter), 
#                                " = ",
#                                
#                                " F (",
#                                as.character(stats.res.df$numDF), 
#                                ",",
#                                as.character(stats.res.df$denDF), 
#                                ") = ",
#                                as.character(round(stats.res.df$`FValue` , digits = round.to) ), 
#                                ", p = ",
#                                as.character(round(stats.res.df$`p-value-corrected` , digits = round.to) ), 
#                                ", ep = ",
#                                as.character(round(stats.res.df$`ep-value-corrected` , digits = round.to) ), 
#                                ", Linear Mixed-Effects)")


# names(stats.res.df)
```

```{reval=FALSE, include=FALSE}
if (exists(x = "stats.res.df")){
  backup.stats.res.df <- stats.res.df
  # stats.res.df <- backup.stats.res.df
  
} else {
  stats.res.df <- read.csv(file = here("data", "stats", "allresampledstats_10k.csv"))
}

## We decided against using the voltage clamp data here so we'll extract it. 
stats.res.df <- stats.res.df %>% dplyr::filter(DV %in% c("gj",
                          "rc",
                          "r12",
                          "cc",
                          "rmp", "r11",
                          "r1"))


if (sum(names(stats.res.df) == "p.value") == 1){
  stats.res.df <- stats.res.df %>% 
  dplyr::filter(!is.na(Groups)) %>% 
  dplyr::filter(DV %in% c("gj",
                          "rc",
                          "r12",
                          "cc",
                          "rmp", "r11",
                          "r1",
                          "intercept.peak_htk",
                          "slope.peak_htk", "intercept.end_htk", "slope.end_htk",
                          "intercept.peak_a",
                          "slope.peak_a", "intercept.end_a", "slope.end_a")) %>% 
  group_by(Groups) %>% 
  mutate(
    `p-value-holm` = p.adjust(`p.value`, method = "holm"),
    `ep-value-holm` = p.adjust(`ep.value`, method = "holm"),
    `p-value-hochberg` = p.adjust(`p.value`, method = "hochberg"),
    `ep-value-hochberg` = p.adjust(`ep.value`, method = "hochberg"),
    `p-value-hommel` = p.adjust(`p.value`, method = "hommel"),
    `ep-value-hommel` = p.adjust(`ep.value`, method = "hommel"),
    `p-value-BY` = p.adjust(`p.value`, method = "BY"),
    `ep-value-BY` = p.adjust(`ep.value`, method = "BY"),
    `p-value-fdr` = p.adjust(`p.value`, method = "fdr"),
    `ep-value-fdr` = p.adjust(`ep.value`, method = "fdr"),
  ) %>% ungroup()
} else if (sum(names(stats.res.df) == "p-value") == 1){
  stats.res.df <- stats.res.df %>% 
  dplyr::filter(!is.na(Groups)) %>% 
  dplyr::filter(DV %in% c("gj",
                          "rc",
                          "r12",
                          "cc",
                          "rmp", "r11",
                          "r1",
                          "intercept.peak_htk",
                          "slope.peak_htk", "intercept.end_htk", "slope.end_htk",
                          "intercept.peak_a",
                          "slope.peak_a", "intercept.end_a", "slope.end_a")) %>% 
  group_by(Groups) %>% 
  mutate(
    `p-value-holm` = p.adjust(`p-value`, method = "holm"),
    `ep-value-holm` = p.adjust(`ep-value`, method = "holm"),
    `p-value-hochberg` = p.adjust(`p-value`, method = "hochberg"),
    `ep-value-hochberg` = p.adjust(`ep-value`, method = "hochberg"),
    `p-value-hommel` = p.adjust(`p-value`, method = "hommel"),
    `ep-value-hommel` = p.adjust(`ep-value`, method = "hommel"),
    `p-value-BY` = p.adjust(`p-value`, method = "BY"),
    `ep-value-BY` = p.adjust(`ep-value`, method = "BY"),
    `p-value-fdr` = p.adjust(`p-value`, method = "fdr"),
    `ep-value-fdr` = p.adjust(`ep-value`, method = "fdr"),
  ) %>% ungroup()
} 


stats.res.df$`p-value-corrected` <- stats.res.df$`p-value-fdr`  
stats.res.df$`ep-value-corrected` <- stats.res.df$`p-value-fdr` 


stats.res.df$DVPrint <- ifelse(stats.res.df$DV == "gj", "gj-1",# FIXME
                               ifelse(stats.res.df$DV == "rc", "Rc",
                                      ifelse(stats.res.df$DV == "r12", "R12",
                                             ifelse(stats.res.df$DV == "cc", "CC",
                                                    ifelse(stats.res.df$DV == "rmp", "RMP",
                                                           ifelse(stats.res.df$DV == "r11", "R11",
                                                           ifelse(stats.res.df$DV == "r1", "R1",
                                                                  
                                                                  
                        ifelse(stats.res.df$DV == "intercept.peak_htk", "IHTK transient intercept",
                               ifelse(stats.res.df$DV == "slope.peak_htk", "IHTK transient slope",
                                      ifelse(stats.res.df$DV == "intercept.end_htk", "IHTK sustained intercept",
                                             ifelse(stats.res.df$DV == "slope.end_htk", "IHTK sustained slope",
                                                    
                        ifelse(stats.res.df$DV == "intercept.peak_a", "IA transient intercept",
                               ifelse(stats.res.df$DV == "slope.peak_a", "IA transient slope",
                                      ifelse(stats.res.df$DV == "intercept.end_a", "IA sustained intercept",
                                             ifelse(stats.res.df$DV == "slope.end_a", "IA sustained slope", 
                                                    NA )
                                                                                                                   )
                                                                                                            )
                                                                                                     )
                                                                                              )
                                                                                       )
                                                                                )
                                                                         )
                                                                  )       
                                                                  
                                                           )
                                                    )
                                                    
                                             )
                                      )
                                      
                               )
)



DV_Cols_for_excel <- data.frame(
  stringsAsFactors = FALSE,
  DVPrint = c("gj-1","Rc","R12","CC",
              "RMP","R11","R1","IHTK transient intercept",
              "IHTK transient slope","IHTK sustained intercept",
              "IHTK sustained slope","IA transient intercept","IA transient slope",
              "IA sustained intercept","IA sustained slope"),
  Txt_Raw = c("g","R","R","CC","RMP","R",
              "R","I","I","I","I","I","I","I","I"),
  Txt_SScript1 = c("j","c","12",NA,NA,"11",
                   "1","HTK","HTK","HTK","HTK","A","A","A","A"),
  Txt_SScript2 = c("-1",NA,NA,NA,NA,NA,NA,NA,
                   NA,NA,NA,NA,NA,NA,NA)
)



stats.res.df <- full_join(stats.res.df, DV_Cols_for_excel)

round.to <- 3
stats.res.df <- rename(stats.res.df, "FValue" = starts_with("F", ignore.case = F)) 

if (sum(names(stats.res.df) == "p-value") == 1){
  stats.res.df <- stats.res.df %>% rename("pValue" =  "p-value")  
} else if (sum(names(stats.res.df) == "p.value") == 1){
  stats.res.df <- stats.res.df %>% rename("pValue" =  "p.value")
}

if  (sum(names(stats.res.df) == "ep-value") == 1){
  stats.res.df <- stats.res.df %>% rename("epValue" =  "ep-value")
} else if (sum(names(stats.res.df) == "ep.value") == 1){
  stats.res.df <- stats.res.df %>% rename("epValue" =  "ep.value")
}



# This is broken into two parts because of the difficulty getting subscripts to work.
stats.res.df$Journal <-  paste0(
  # "(",
  #                              as.character(stats.res.df$DVPrint),
                               " ",
                               as.character(stats.res.df$Parameter), 
                               " = ",
                               
                               " F (",
                               as.character(stats.res.df$numDF), 
                               ",",
                               as.character(stats.res.df$denDF), 
                               ") = ",
                               as.character(round(stats.res.df$`FValue` , digits = round.to) ), 
                               ", p = ",
                               as.character(round(stats.res.df$`p-value-corrected` , digits = round.to) ), 
                               ", ep = ",
                               as.character(round(stats.res.df$`ep-value-corrected` , digits = round.to) ), 
                               ", Linear Mixed-Effects)"
)


#order to be more user friendly

first.names <- c("Journal",
                 "Groups", "DV", "Parameter", 
                 "numDF", "denDF", 
                 # "F-value", 
                 # "p-value",  
                 "pValue",
                 # "epValue",
                 
                 "p-value-holm",
                 "p-value-hochberg",
                 "p-value-hommel",
                 "p-value-BY",
                 "p-value-fdr",
                 
                 # "ep-value",
                 "epValue",
                 
                 "ep-value-holm",
                 "ep-value-hochberg",
                 "ep-value-hommel",
                 "ep-value-BY",
                 "ep-value-fdr",
                 
                 "p-value-corrected", "ep-value-corrected", 
                 "Time")
last.names <- names(stats.res.df)[!(names(stats.res.df) %in% first.names)]

stats.res.df <- stats.res.df[, c(first.names, last.names)]


## get effect estimates in an easily reported manner ====



stats.res.df <- stats.res.df %>% 
  mutate(TimeEst = paste0(
    # "(", as.character(DVPrint), 
    " Time = ", 
                         as.character(round(Time, digits = round.to)), ")")) %>% 
  mutate(MainEst = 
           ifelse(Groups == "PS.0.High.Amp_PS.22.High.Amp", 
                  paste0(
                    # "(", as.character(DVPrint), 
                    " TEA Mimic = ", 
                         as.character(round(ConditionPS.22.High.Amp, digits = round.to)), ")"), 
                  
           ifelse(Groups == "PS.22.High.Amp_PS.90.HA", 
                  paste0(
                    # "(", as.character(DVPrint), 
                    " Depolarized = ", 
                         as.character(round(ConditionPS.90.HA, digits = round.to)), ")"),   
                  
           ifelse(Groups == "PS.90.HA_PS.90.HA.Cd",
                  paste0(
                    # "(", as.character(DVPrint), 
                    " Cd2+ = ", 
                         as.character(round(ConditionPS.90.HA.Cd, digits = round.to)), ")"),   
                  
           ifelse(Groups == "PS.0_PS.22_PS.45_PS.90",
                  paste0(
                    # "(", as.character(DVPrint), 
                    " 22, 45, 90 = ", 
                         as.character(round(ConditionPS.22, digits = round.to)), " ",
                         as.character(round(ConditionPS.45, digits = round.to)), " ",
                         as.character(round(ConditionPS.90, digits = round.to)), ")"),
                  
           ifelse(Groups == "PS.0.orig_PS.22.orig_PS.45.orig_PS.90.orig_PS.180.orig",
                  paste0(
                    # "(", as.character(DVPrint), 
                    " 22, 45, 90, 180 = ", 
                         as.character(round(ConditionPS.22.orig, digits = round.to)), " ",
                         as.character(round(ConditionPS.45.orig, digits = round.to)), " ",
                         as.character(round(ConditionPS.90.orig, digits = round.to)), " ",
                         as.character(round(ConditionPS.180.orig, digits = round.to)), ")"), 
                  NA)))))
         
         
         ) %>% 
  mutate(IntrEst = 
           ifelse(Groups == "PS.0.High.Amp_PS.22.High.Amp", 
                  paste0(
                    # "(", as.character(DVPrint), 
                         " Time:TEA Mimic = ", 
                         as.character(round(`Time.ConditionPS.22.High.Amp`, digits = round.to)), ")"), 
                  
           ifelse(Groups == "PS.22.High.Amp_PS.90.HA", 
                  paste0(
                    # "(", as.character(DVPrint), 
                    " Time:Depolarized = ", 
                         as.character(round(`Time.ConditionPS.90.HA`, digits = round.to)), ")"),   
                  
           ifelse(Groups == "PS.90.HA_PS.90.HA.Cd",
                  paste0(
                    # "(", as.character(DVPrint), 
                    " Time.Cd2+ = ", 
                         as.character(round(`Time.ConditionPS.90.HA.Cd`, digits = round.to)), ")"),   
                  
           ifelse(Groups == "PS.0_PS.22_PS.45_PS.90",
                  paste0(
                    # "(", as.character(DVPrint), 
                    " Time: 22, 45, 90 = ", 
                         as.character(round(`Time.ConditionPS.22`, digits = round.to)), " ",
                         as.character(round(`Time.ConditionPS.45`, digits = round.to)), " ",
                         as.character(round(`Time.ConditionPS.90`, digits = round.to)), ")"),
                  
           ifelse(Groups == "PS.0.orig_PS.22.orig_PS.45.orig_PS.90.orig_PS.180.orig",
                  paste0(
                    # "(", as.character(DVPrint), 
                    " Time: 22, 45, 90, 180 = ", 
                         as.character(round(`Time.ConditionPS.22.orig`, digits = round.to)), " ", #FIXME not found
                         as.character(round(`Time.ConditionPS.45.orig`, digits = round.to)), " ",
                         as.character(round(`Time.ConditionPS.90.orig`, digits = round.to)), " ",
                         as.character(round(`Time.ConditionPS.180.orig`, digits = round.to)), ")"), 
                  NA))))))



# paste0("(", as.character(DVPrint), " ___ = ", 
        #                  as.character(round(___, digits = round.to)), ")"),                            
                

## re order for easier referencing ====
# write_out <- full_join(arrange(stats.res.df, Groups, DV), Cd2.tost.stat)
stats.res.df <- full_join(stats.res.df, Cd2.tost.stat)
write_out <- arrange(stats.res.df, Groups, DV)
# names(write_out)

write_out$Journal_wr <- NA
write_out$TimeEst_wr <- NA
write_out$MainEst_wr <- NA
write_out$IntrEst_wr <- NA

put_these_cols_first <- c("Journal_wr", "TimeEst_wr", "MainEst_wr", "IntrEst_wr", 
                          "Txt_Raw", "Txt_SScript1", "Txt_SScript2", 
                          "Journal", "TimeEst", "MainEst", "IntrEst" )


write.csv(write_out[, c(put_these_cols_first, names(write_out)[!(names(write_out) %in% put_these_cols_first)])] , file = here("data", "stats", "JNeurosciStats_10k_NoVoltageClamp.csv"))
# write.csv(write_out[, c(put_these_cols_first, names(write_out)[!(names(write_out) %in% put_these_cols_first)])] , file = here("data", "stats", "JNeurosciStats_100.csv"))

```


```{r}
# if (exists(x = "stats.res.df")){
#   backup.stats.res.df <- stats.res.df
#   # stats.res.df <- backup.stats.res.df
#   
# } else {
#   stats.res.df <- read.csv(file = here("data", "stats", "allresampledstats_10k.csv"))
# }
# 
# 
# 
# # Adjust for journal reporting
# # stats.res.df <- stats.res.df %>% dplyr::filter(Parameter != "(Intercept)") %>% dplyr::filter(DV != "R12")
# 
# stats.res.group.list <- map(unique(stats.res.df$Groups)[!(is.na(unique(stats.res.df$Groups)))], function(Group){ # NA is creeping into "Groups" and causing problems
#   stats.res.df[stats.res.df$Groups == Group, ]
# })
# 
# # for (i in seq_along(stats.res.group.list)){
# #   # print(unique(stats.res.group.list[[i]]$Groups))
# #   # print(head(stats.res.group.list[[i]][, c("Parameter", "numDF", "denDF", "p-value")]))
# #   print(sum(is.na(stats.res.group.list[[i]]$`p-value`)))
# # }
# # 
# # i = 1
# # stats.res.group.list[[i]][is.na(stats.res.group.list[[i]]$`p-value`), ]
# 
# 
# 
# 
# stats.res.group.list2 <- map(seq_along(stats.res.group.list), function(i){
#   for (i in seq_along(stats.res.group.list)){
#     print(i)
#   
#   temp <- stats.res.group.list[[i]]
#   tempBackup <- stats.res.group.list[[i]]
#   
#       DVs.to.keep <- c(
#       "gj",
#       "rc",
#       "r12",
#       "cc",
#       "rmp", "r11",
#       "r1",
#       "intercept.peak_htk",
#       "slope.peak_htk", "intercept.end_htk", "slope.end_htk",
#       "intercept.peak_a",
#       "slope.peak_a", "intercept.end_a", "slope.end_a"
#     )
# 
#   
#   # Drop tests we're not intersted in
#   temp <- temp[temp$DV %in% DVs.to.keep, ]
# 
#   # WARNING: names change!
#   if (length(unique(temp$p.value)) > 2 & length(unique(temp$ep.value)) > 1 ){
#     temp$`p-value-holm` <- p.adjust(temp$`p.value`, method = "holm")
#     temp$`ep-value-holm` <- p.adjust(temp$`ep.value`, method = "holm")
#     temp$`p-value-hochberg` <- p.adjust(temp$`p.value`, method = "hochberg")
#     temp$`ep-value-hochberg` <- p.adjust(temp$`ep.value`, method = "hochberg")
#     temp$`p-value-hommel` <- p.adjust(temp$`p.value`, method = "hommel")
#     temp$`ep-value-hommel` <- p.adjust(temp$`ep.value`, method = "hommel")
#     temp$`p-value-BY` <- p.adjust(temp$`p.value`, method = "BY")
#     temp$`ep-value-BY` <- p.adjust(temp$`ep.value`, method = "BY")
#     temp$`p-value-fdr` <- p.adjust(temp$`p.value`, method = "fdr")
#     temp$`ep-value-fdr` <- p.adjust(temp$`ep.value`, method = "fdr")
#   } else {
#     temp$`p-value-holm` <- NA
#     temp$`ep-value-holm` <- NA
#     temp$`p-value-hochberg` <- NA
#     temp$`ep-value-hochberg` <- NA
#     temp$`p-value-hommel` <- NA
#     temp$`ep-value-hommel` <- NA
#     temp$`p-value-BY` <- NA
#     temp$`ep-value-BY` <- NA
#     temp$`p-value-fdr` <- NA
#     temp$`ep-value-fdr` <- NA
#   }
#   
#   }
#   
#   
#   return(full_join(tempBackup, temp))
# })
# 
# 
# # walk(seq_along(stats.res.group.list), function(i){
# #   stats.res.group.list[[i]]$`p-value-holm` <<- p.adjust(stats.res.group.list[[i]]$`p-value`, method = "holm")
# #   stats.res.group.list[[i]]$`ep-value-holm` <<- p.adjust(stats.res.group.list[[i]]$`ep-value`, method = "holm")
# #   stats.res.group.list[[i]]$`p-value-hochberg` <<- p.adjust(stats.res.group.list[[i]]$`p-value`, method = "hochberg")
# #   stats.res.group.list[[i]]$`ep-value-hochberg` <<- p.adjust(stats.res.group.list[[i]]$`ep-value`, method = "hochberg")
# #   stats.res.group.list[[i]]$`p-value-hommel` <<- p.adjust(stats.res.group.list[[i]]$`p-value`, method = "hommel")
# #   stats.res.group.list[[i]]$`ep-value-hommel` <<- p.adjust(stats.res.group.list[[i]]$`ep-value`, method = "hommel")
# #   stats.res.group.list[[i]]$`p-value-BY` <<- p.adjust(stats.res.group.list[[i]]$`p-value`, method = "BY")
# #   stats.res.group.list[[i]]$`ep-value-BY` <<- p.adjust(stats.res.group.list[[i]]$`ep-value`, method = "BY")
# #   stats.res.group.list[[i]]$`p-value-fdr` <<- p.adjust(stats.res.group.list[[i]]$`p-value`, method = "fdr")
# #   stats.res.group.list[[i]]$`ep-value-fdr` <<- p.adjust(stats.res.group.list[[i]]$`ep-value`, method = "fdr")
# # })
# 
# stats.res.df <- do.call(rbind, stats.res.group.list2)
# 
# 
# stats.res.df$`p-value-corrected` <- stats.res.df$`p-value-fdr`  
# stats.res.df$`ep-value-corrected` <- stats.res.df$`p-value-fdr` 
# 
# stats.res.df$DVPrint <- ifelse(stats.res.df$DV == "gj", "gj-1",# FIXME
#                                ifelse(stats.res.df$DV == "rc", "Rc",
#                                       ifelse(stats.res.df$DV == "r12", "R12",
#                                              ifelse(stats.res.df$DV == "cc", "CC",
#                                                     ifelse(stats.res.df$DV == "rmp", "RMP",
#                                                            ifelse(stats.res.df$DV == "r11", "R11",
#                                                            ifelse(stats.res.df$DV == "r1", "R1",
#                                                                   
#                                                                   
#                         ifelse(stats.res.df$DV == "intercept.peak_htk", "IHTK transient intercept",
#                                ifelse(stats.res.df$DV == "slope.peak_htk", "IHTK transient slope",
#                                       ifelse(stats.res.df$DV == "intercept.end_htk", "IHTK sustained intercept",
#                                              ifelse(stats.res.df$DV == "slope.end_htk", "IHTK sustained slope",
#                                                     
#                         ifelse(stats.res.df$DV == "intercept.peak_a", "IA transient intercept",
#                                ifelse(stats.res.df$DV == "slope.peak_a", "IA transient slope",
#                                       ifelse(stats.res.df$DV == "intercept.end_a", "IA sustained intercept",
#                                              ifelse(stats.res.df$DV == "slope.end_a", "IA sustained slope", 
#                                                     NA )
#                                                                                                                    )
#                                                                                                             )
#                                                                                                      )
#                                                                                               )
#                                                                                        )
#                                                                                 )
#                                                                          )
#                                                                   )       
#                                                                   
#                                                            )
#                                                     )
#                                                     
#                                              )
#                                       )
#                                       
#                                )
# )
# 
# 
# 
# DV_Cols_for_excel <- data.frame(
#   stringsAsFactors = FALSE,
#   DVPrint = c("gj-1","Rc","R12","CC",
#               "RMP","R11","R1","IHTK transient intercept",
#               "IHTK transient slope","IHTK sustained intercept",
#               "IHTK sustained slope","IA transient intercept","IA transient slope",
#               "IA sustained intercept","IA sustained slope"),
#   Txt_Raw = c("g","R","R","CC","RMP","R",
#               "R","I","I","I","I","I","I","I","I"),
#   Txt_SScript1 = c("j","c","12",NA,NA,"11",
#                    "1","HTK","HTK","HTK","HTK","A","A","A","A"),
#   Txt_SScript2 = c("-1",NA,NA,NA,NA,NA,NA,NA,
#                    NA,NA,NA,NA,NA,NA,NA)
# )
# 
# 
# 
# stats.res.df <- full_join(stats.res.df, DV_Cols_for_excel)
# 
# round.to <- 3
# stats.res.df <- rename(stats.res.df, "FValue" = starts_with("F", ignore.case = F)) 
# 
# if (sum(names(stats.res.df) == "p-value") == 1){
#   stats.res.df <- stats.res.df %>% rename("pValue" =  "p-value")  
# } else if (sum(names(stats.res.df) == "p.value") == 1){
#   stats.res.df <- stats.res.df %>% rename("pValue" =  "p.value")
# }
# 
# if  (sum(names(stats.res.df) == "ep-value") == 1){
#   stats.res.df <- stats.res.df %>% rename("epValue" =  "ep-value")
# } else if (sum(names(stats.res.df) == "ep.value") == 1){
#   stats.res.df <- stats.res.df %>% rename("epValue" =  "ep.value")
# }
# 
# 
# 
# # This is broken into two parts because of the difficulty getting subscripts to work.
# stats.res.df$Journal <-  paste0(
#   # "(",
#   #                              as.character(stats.res.df$DVPrint),
#                                " ",
#                                as.character(stats.res.df$Parameter), 
#                                " = ",
#                                
#                                " F (",
#                                as.character(stats.res.df$numDF), 
#                                ",",
#                                as.character(stats.res.df$denDF), 
#                                ") = ",
#                                as.character(round(stats.res.df$`FValue` , digits = round.to) ), 
#                                ", p = ",
#                                as.character(round(stats.res.df$`p-value-corrected` , digits = round.to) ), 
#                                ", ep = ",
#                                as.character(round(stats.res.df$`ep-value-corrected` , digits = round.to) ), 
#                                ", Linear Mixed-Effects)"
# )
# 
# 
# #order to be more user friendly
# 
# first.names <- c("Journal",
#                  "Groups", "DV", "Parameter", 
#                  "numDF", "denDF", 
#                  # "F-value", 
#                  # "p-value",  
#                  "pValue",
#                  # "epValue",
#                  
#                  "p-value-holm",
#                  "p-value-hochberg",
#                  "p-value-hommel",
#                  "p-value-BY",
#                  "p-value-fdr",
#                  
#                  # "ep-value",
#                  "epValue",
#                  
#                  "ep-value-holm",
#                  "ep-value-hochberg",
#                  "ep-value-hommel",
#                  "ep-value-BY",
#                  "ep-value-fdr",
#                  
#                  "p-value-corrected", "ep-value-corrected", 
#                  "Time")
# last.names <- names(stats.res.df)[!(names(stats.res.df) %in% first.names)]
# 
# stats.res.df <- stats.res.df[, c(first.names, last.names)]
# 
# 
# ## get effect estimates in an easily reported manner ====
# 
# 
# 
# stats.res.df <- stats.res.df %>% 
#   mutate(TimeEst = paste0(
#     # "(", as.character(DVPrint), 
#     " Time = ", 
#                          as.character(round(Time, digits = round.to)), ")")) %>% 
#   mutate(MainEst = 
#            ifelse(Groups == "PS.0.High.Amp_PS.22.High.Amp", 
#                   paste0(
#                     # "(", as.character(DVPrint), 
#                     " TEA Mimic = ", 
#                          as.character(round(ConditionPS.22.High.Amp, digits = round.to)), ")"), 
#                   
#            ifelse(Groups == "PS.22.High.Amp_PS.90.HA", 
#                   paste0(
#                     # "(", as.character(DVPrint), 
#                     " Depolarized = ", 
#                          as.character(round(ConditionPS.90.HA, digits = round.to)), ")"),   
#                   
#            ifelse(Groups == "PS.90.HA_PS.90.HA.Cd",
#                   paste0(
#                     # "(", as.character(DVPrint), 
#                     " Cd2+ = ", 
#                          as.character(round(ConditionPS.90.HA.Cd, digits = round.to)), ")"),   
#                   
#            ifelse(Groups == "PS.0_PS.22_PS.45_PS.90",
#                   paste0(
#                     # "(", as.character(DVPrint), 
#                     " 22, 45, 90 = ", 
#                          as.character(round(ConditionPS.22, digits = round.to)), " ",
#                          as.character(round(ConditionPS.45, digits = round.to)), " ",
#                          as.character(round(ConditionPS.90, digits = round.to)), ")"),
#                   
#            ifelse(Groups == "PS.0.orig_PS.22.orig_PS.45.orig_PS.90.orig_PS.180.orig",
#                   paste0(
#                     # "(", as.character(DVPrint), 
#                     " 22, 45, 90, 180 = ", 
#                          as.character(round(ConditionPS.22.orig, digits = round.to)), " ",
#                          as.character(round(ConditionPS.45.orig, digits = round.to)), " ",
#                          as.character(round(ConditionPS.90.orig, digits = round.to)), " ",
#                          as.character(round(ConditionPS.180.orig, digits = round.to)), ")"), 
#                   NA)))))
#          
#          
#          ) %>% 
#   mutate(IntrEst = 
#            ifelse(Groups == "PS.0.High.Amp_PS.22.High.Amp", 
#                   paste0(
#                     # "(", as.character(DVPrint), 
#                          " Time:TEA Mimic = ", 
#                          as.character(round(Time.ConditionPS.22.High.Amp, digits = round.to)), ")"), 
#                   
#            ifelse(Groups == "PS.22.High.Amp_PS.90.HA", 
#                   paste0(
#                     # "(", as.character(DVPrint), 
#                     " Time:Depolarized = ", 
#                          as.character(round(Time.ConditionPS.90.HA, digits = round.to)), ")"),   
#                   
#            ifelse(Groups == "PS.90.HA_PS.90.HA.Cd",
#                   paste0(
#                     # "(", as.character(DVPrint), 
#                     " Time:Cd2+ = ", 
#                          as.character(round(Time.ConditionPS.90.HA.Cd, digits = round.to)), ")"),   
#                   
#            ifelse(Groups == "PS.0_PS.22_PS.45_PS.90",
#                   paste0(
#                     # "(", as.character(DVPrint), 
#                     " Time: 22, 45, 90 = ", 
#                          as.character(round(Time.ConditionPS.22, digits = round.to)), " ",
#                          as.character(round(Time.ConditionPS.45, digits = round.to)), " ",
#                          as.character(round(Time.ConditionPS.90, digits = round.to)), ")"),
#                   
#            ifelse(Groups == "PS.0.orig_PS.22.orig_PS.45.orig_PS.90.orig_PS.180.orig",
#                   paste0(
#                     # "(", as.character(DVPrint), 
#                     " Time: 22, 45, 90, 180 = ", 
#                          as.character(round(Time.ConditionPS.22.orig, digits = round.to)), " ", #FIXME not found
#                          as.character(round(Time.ConditionPS.45.orig, digits = round.to)), " ",
#                          as.character(round(Time.ConditionPS.90.orig, digits = round.to)), " ",
#                          as.character(round(Time.ConditionPS.180.orig, digits = round.to)), ")"), 
#                   NA))))))
# 
# 
# 
#         # paste0("(", as.character(DVPrint), " ___ = ", 
#         #                  as.character(round(___, digits = round.to)), ")"),                            
#                 
# 
# ## re order for easier referencing ====
# # write_out <- full_join(arrange(stats.res.df, Groups, DV), Cd2.tost.stat)
# stats.res.df <- full_join(stats.res.df, Cd2.tost.stat)
# write_out <- arrange(stats.res.df, Groups, DV)
# # names(write_out)
# 
# write_out$Journal_wr <- NA
# write_out$TimeEst_wr <- NA
# write_out$MainEst_wr <- NA
# write_out$IntrEst_wr <- NA
# 
# put_these_cols_first <- c("Journal_wr", "TimeEst_wr", "MainEst_wr", "IntrEst_wr", 
#                           "Txt_Raw", "Txt_SScript1", "Txt_SScript2", 
#                           "Journal", "TimeEst", "MainEst", "IntrEst" )
# 
# 
# write.csv(write_out[, c(put_these_cols_first, names(write_out)[!(names(write_out) %in% put_these_cols_first)])] , file = here("data", "stats", "JNeurosciStats_10k.csv"))
# # write.csv(write_out[, c(put_these_cols_first, names(write_out)[!(names(write_out) %in% put_these_cols_first)])] , file = here("data", "stats", "JNeurosciStats_100.csv"))
# #
```







# figures explicit
figures above are missing 20,60

```{r}

condition.labs <- c("TEA Mimic Sync", "TEA Mimic Async", "Depol. Async", "Depol. Async Cd2+",
                    "Standardized \n0 Deg.", "Standardized \n22.5 Deg.", "Standardized \n45 Deg.", "Standardized \n90 Deg.",
                    "Individualized \n0 Deg.", "Individualized \n22.5 Deg.", "Individualized \n45 Deg.", "Individualized \n90 Deg.", "Individualized \n180 Deg.")

names(condition.labs) <- c("PS.0.High.Amp", "PS.22.High.Amp", "PS.90.HA", "PS.90.HA.Cd",
                           "PS.0", "PS.22", "PS.45", "PS.90",
                           "PS.0.orig", "PS.22.orig", "PS.45.orig", "PS.90.orig", "PS.180.orig")
  
M.clean$Condition <- factor(M.clean$Condition, levels = c("PS.0.High.Amp", "PS.22.High.Amp", "PS.90.HA", "PS.90.HA.Cd",
                                                          "PS.0", "PS.22", "PS.45", "PS.90",
                                                          "PS.0.orig", "PS.22.orig", "PS.45.orig", "PS.90.orig", "PS.180.orig"))

### Params ####
text.size = 20
point.size = 3
line.size = 3
mean.point.size = 3
mean.line.size = 3

### High Amplitude Plots ####
plt.tea <- M.clean[M.clean$Condition %in% c("PS.0.High.Amp", "PS.22.High.Amp"), ] %>% 
  dplyr::select(Condition, Experiment, Inj_Cell, Time, gj) %>% 
  group_by(Condition, Experiment, Inj_Cell, Time) %>%
  summarise(gj = mean(gj, na.rm = T)) %>% 
  ungroup() %>% 
  # mutate(Time = as.character(Time)) %>% 
  pivot_wider(names_from = Time, values_from = gj) %>% 
  mutate(`20` = `20` - `0`,
         `40` = `40` - `0`,
         `60` = `60` - `0`) %>% 
  mutate(`0` = 0) %>% 
  pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "gj") %>% 
  group_by(Condition, Time) %>% 
  mutate(mean_gj = mean(gj, na.rm = T),
         mean_sd_up = mean_gj+sd(gj, na.rm = T),
         mean_sd_dn =mean_gj- sd(gj, na.rm = T),) %>% 
  mutate(inter = paste(Experiment, Inj_Cell, sep = ".")) %>% 
  ggplot(aes(x = Time, 
             y = gj, 
             # color = Experiment, 
             # shape = Inj_Cell, 
             group = inter))+
  geom_ribbon(aes(ymin=mean_sd_dn, ymax=mean_sd_up), fill = "gray", alpha = 0.1)+
  lemon::geom_pointline(size = point.size, linesize = line.size)+
  geom_point(aes(x = Time, y = mean_gj), color = "white", size = mean.point.size, alpha = 0.3)+
  geom_pointline(aes(x = Time, y = mean_gj), color = "firebrick", size = mean.point.size, linesize = mean.line.size,  shape = 1)+
  labs(y = expression(paste(Delta, "Rc", " in M", Omega)), x = "Time in Minutes")+
  facet_grid(.~Condition,
             labeller = labeller(Condition = condition.labs))+
  geom_hline(yintercept = 0)+
  theme(
    # axis.text = element_text(size = rel(2), angle = 0),
        text = element_text(size=text.size)
        )

plt.hv <- M.clean[M.clean$Condition %in% c("PS.90.HA", "PS.90.HA.Cd" ), ] %>% 
  dplyr::select(Condition, Experiment, Inj_Cell, Time, gj) %>% 
  group_by(Condition, Experiment, Inj_Cell, Time) %>%
  summarise(gj = mean(gj, na.rm = T)) %>% 
  ungroup() %>% 
  # mutate(Time = as.character(Time)) %>% 
  pivot_wider(names_from = Time, values_from = gj) %>% 
  mutate(`20` = `20` - `0`,
         `40` = `40` - `0`,
         `60` = `60` - `0`) %>% 
  mutate(`0` = 0) %>% 
  pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "gj") %>% 
  group_by(Condition, Time) %>% 
  mutate(mean_gj = mean(gj, na.rm = T),
         mean_sd_up = mean_gj+sd(gj, na.rm = T),
         mean_sd_dn =mean_gj- sd(gj, na.rm = T),) %>% 
  mutate(inter = paste(Experiment, Inj_Cell, sep = ".")) %>% 
  ggplot(aes(x = Time, 
             y = gj, 
             # color = Experiment, 
             # shape = Inj_Cell, 
             group = inter))+
  geom_ribbon(aes(ymin=mean_sd_dn, ymax=mean_sd_up), fill = "gray", alpha = 0.1)+
  lemon::geom_pointline(size = point.size, linesize = line.size)+
  geom_point(aes(x = Time, y = mean_gj), color = "white", size = mean.point.size, alpha = 0.3)+
  geom_pointline(aes(x = Time, y = mean_gj), color = "firebrick", size = mean.point.size, linesize = mean.line.size,  shape = 1)+
  labs(y = expression(paste(Delta, "Rc", " in M", Omega)), x = "Time in Minutes")+
  facet_grid(.~Condition,
             labeller = labeller(Condition = condition.labs))+
  geom_hline(yintercept = 0)+
  theme(
    # axis.text = element_text(size = rel(2), angle = 0),
        text = element_text(size=text.size)
        )




### Low Voltage plots ####
plt.lv <- M.clean[M.clean$Condition %in% c("PS.0", "PS.22", "PS.45", "PS.90"), ] %>% 
  dplyr::select(Condition, Experiment, Inj_Cell, Time, gj) %>% 
  group_by(Condition, Experiment, Inj_Cell, Time) %>%
  summarise(gj = mean(gj, na.rm = T)) %>% 
  ungroup() %>% 
  # mutate(Time = as.character(Time)) %>% 
  pivot_wider(names_from = Time, values_from = gj) %>% 
  mutate(`20` = `20` - `0`,
         `40` = `40` - `0`,
         `60` = `60` - `0`) %>% 
  mutate(`0` = 0) %>% 
  pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "gj") %>% 
  group_by(Condition, Time) %>% 
  mutate(mean_gj = mean(gj, na.rm = T),
         mean_sd_up = mean_gj+sd(gj, na.rm = T),
         mean_sd_dn =mean_gj- sd(gj, na.rm = T),) %>% 
  mutate(inter = paste(Experiment, Inj_Cell, sep = ".")) %>% 
  ggplot(aes(x = Time, 
             y = gj, 
             # color = Experiment, 
             # shape = Inj_Cell, 
             group = inter))+
  geom_ribbon(aes(ymin=mean_sd_dn, ymax=mean_sd_up), fill = "gray", alpha = 0.1)+
  lemon::geom_pointline(size = point.size, linesize = line.size)+
  geom_point(aes(x = Time, y = mean_gj), color = "white", size = mean.point.size, alpha = 0.3)+
  geom_pointline(aes(x = Time, y = mean_gj), color = "firebrick", size = mean.point.size, linesize = mean.line.size,  shape = 1)+
  labs(y = expression(paste(Delta, "Rc", " in M", Omega)), x = "Time in Minutes")+
  facet_grid(.~Condition,
             labeller = labeller(Condition = condition.labs))+
  geom_hline(yintercept = 0)+
  theme(
    # axis.text = element_text(size = rel(2), angle = 0),
        text = element_text(size=text.size)
        )

### Low Voltage naturalistic ####
plt.nv <- M.clean[M.clean$Condition %in% c("PS.0.orig", "PS.22.orig", "PS.45.orig", "PS.90.orig", "PS.180.orig"), ] %>% 
  dplyr::select(Condition, Experiment, Inj_Cell, Time, gj) %>% 
  group_by(Condition, Experiment, Inj_Cell, Time) %>%
  summarise(gj = mean(gj, na.rm = T)) %>% 
  ungroup() %>% 
  # mutate(Time = as.character(Time)) %>% 
  pivot_wider(names_from = Time, values_from = gj) %>% 
  mutate(`20` = `20` - `0`,
         `40` = `40` - `0`,
         `60` = `60` - `0`) %>% 
  mutate(`0` = 0) %>% 
  pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "gj") %>% 
  group_by(Condition, Time) %>% 
  mutate(mean_gj = mean(gj, na.rm = T),
         mean_sd_up = mean_gj+sd(gj, na.rm = T),
         mean_sd_dn =mean_gj- sd(gj, na.rm = T),) %>% 
  mutate(inter = paste(Experiment, Inj_Cell, sep = ".")) %>% 
  ggplot(aes(x = Time, 
             y = gj, 
             # color = Experiment, 
             # shape = Inj_Cell, 
             group = inter))+
  geom_ribbon(aes(ymin=mean_sd_dn, ymax=mean_sd_up), fill = "gray", alpha = 0.1)+
  lemon::geom_pointline(size = point.size, linesize = line.size)+
  geom_point(aes(x = Time, y = mean_gj), color = "white", size = mean.point.size, alpha = 0.3)+
  geom_pointline(aes(x = Time, y = mean_gj), color = "firebrick", size = mean.point.size, linesize = mean.line.size,  shape = 1)+
  labs(y = expression(paste(Delta, "Rc", " in M", Omega)), x = "Time in Minutes")+
  facet_grid(.~Condition,
             labeller = labeller(Condition = condition.labs))+
  geom_hline(yintercept = 0)+
  theme(
    # axis.text = element_text(size = rel(2), angle = 0),
        text = element_text(size=text.size)
        )
```

## Waveform annotations on figs
```{r}
protocol_files <- list.files("D:/Box Sync/AllWorkProjects/dynamicclamp - Copy/inst/extdata/protocol_waveforms/")

data.reduction <- 250

stims <- map(protocol_files, function(i){
  temp <- read.table(paste0("D:/Box Sync/AllWorkProjects/dynamicclamp - Copy/inst/extdata/protocol_waveforms/", i))
  temp <- temp[4:nrow(temp), ]
  names(temp) <- c("Seconds", "mV")
  temp$Seconds <- as.numeric(as.character(temp$Seconds))
  temp$mV <- as.numeric(as.character(temp$mV))
  
  temp$Protocol <- i
  
  # don't data reduce the naturalistic, it's lower res already.
  if (!(i %in% c("170828_lead.atf", 
                 "180717a_follow.atf", 
                 "180718_lead.atf"))) {
    temp <- temp[seq(1, nrow(temp), by = data.reduction), ]    
  }
  
  return(temp)
})

## make 22.5 - 180 shifts for 170828_lead.atf
add.to.stims <- map(c(2, 4, 8, 16), function(i, temp = stims[[which(protocol_files == "170828_lead.atf")]]){
  
  # make shifted times
  shift.by <- floor(nrow(temp) / i)
  temp$Seconds <- c(temp$Seconds[seq(shift.by+1, nrow(temp))], temp$Seconds[seq(1, shift.by)])
  # update Protocol name
  
  temp$Protocol <- stringr::str_remove(temp$Protocol, "lead.atf")
  temp$Protocol <- paste0(temp$Protocol, as.character((1/i)*360), ".atf")  
  
  # since we'll visualize with geom_path we need to sort here.
  temp <- arrange(temp, Seconds)
  
  return(temp)
  
})

# Grow list
for (i in seq_along(add.to.stims)){
  stims[[length(stims)+1]] <- add.to.stims[[i]]
}


stims <- do.call(rbind, stims)
```

```{r}
inset_plts <- map(c("aberrant_depol_man.atf",
                    "aberrant_depol_man_22deg.ATF",
                    "HA_00.ATF",
                    "HA_90.ATF",
                    
                    "180110_stim.atf",
                    "180110_stim_22deg.ATF",
                    "180110_stim_45deg.ATF",
                    "180110_stim_90deg.ATF",
                    
                    "170828_lead.atf",
                    "170828_22.5.atf",
                    "170828_45.atf",
                    "170828_90.atf",
                    "170828_180.atf"), function(i){
                      plt <- stims[stims$Protocol == i, ] %>% 
                        ggplot( aes(Seconds, mV, group = 1))+
                        geom_path()+
                        theme_void()
                    })

names(inset_plts) <- c("tea0", "tea22", "ha0", "ha90",
                       "s0", "s22", "s45", "s90",
                       "n0", "n22", "n45", "n90", "n180")

```

## Prep Figure 1
```{r}

trace.size = 1
bar.size = 2

ex.1 <- 
ggplot()+
  geom_path(data = stims[stims$Protocol %in% c("aberrant_depol_man.atf") , ], aes(Seconds/1000, mV+53.53, group = 1), size = trace.size)+
  geom_segment(aes(x = 0, xend = 0, y = -1, yend = 9), size = bar.size)+
  geom_segment(aes(x = 0, xend = 1, y = -1, yend = -1), size = bar.size)+
  geom_vline(xintercept = 3.9)+
  theme_void()

ex.2 <- 
ggplot()+
  geom_path(data = stims[stims$Protocol %in% c("HA_00.ATF") , ], aes(Seconds, mV+53.53, group = 1), size = trace.size)+
  geom_segment(aes(x = 0, xend = 0, y = -1, yend = 9), size = bar.size)+
  geom_segment(aes(x = 0, xend = 1, y = -1, yend = -1), size = bar.size)+
  theme_void()

ex.3 <- 
ggplot()+
  geom_path(data = stims[stims$Protocol %in% c("180110_stim.atf") , ], aes(Seconds/1000, mV+53.53, group = 1), size = trace.size)+
  geom_segment(aes(x = 0, xend = 0, y = -1, yend = 9), size = bar.size)+
  geom_segment(aes(x = 0, xend = 1, y = -1, yend = -1), size = bar.size)+
  theme_void()


#Control lab position even with different x axis
label.size = 4
label.x.fract = 4/5
label.y = 7

ex.4 <- 
ggplot()+
  geom_path(data = stims[stims$Protocol %in% c("170828_lead.atf") , ], aes(Seconds/1000, mV+43.29, group = 1), size = trace.size)+
  geom_segment(aes(x = 0, xend = 0, y = -1, yend = 9), size = bar.size)+
  geom_segment(aes(x = 0, xend = 1, y = -1, yend = -1), size = bar.size)+
  annotate("text", x = ((label.x.fract)*5.178), y = label.y, label = 'paste(italic(Animal), " ", italic("1"))',  parse = T, size = label.size)+
  theme_void()


ex.5 <- 
ggplot()+
  geom_path(data = stims[stims$Protocol %in% c("180717a_follow.atf") , ], aes(Seconds/1000, mV+55.83, group = 1), size = trace.size, color = "gray")+
  geom_segment(aes(x = 0, xend = 0, y = -1, yend = 9), size = bar.size)+
  geom_segment(aes(x = 0, xend = 1, y = -1, yend = -1), size = bar.size)+
  annotate("text", x = ((label.x.fract)*4.919), y = label.y, label = 'paste(italic(Animal), " ", italic("2"))',  parse = T, size = label.size)+
  theme_void()

ex.6 <- 
ggplot()+
  geom_path(data = stims[stims$Protocol %in% c("180718_lead.atf") , ], aes((Seconds-281297)/1000, mV+62.36, group = 1), size = trace.size, color = "gray")+
  geom_segment(aes(x = 0, xend = 0, y = -1, yend = 9), size = bar.size)+
  geom_segment(aes(x = 0, xend = 1, y = -1, yend = -1), size = bar.size)+
  annotate("text", x = ((label.x.fract)*5.652), y = label.y, label = 'paste(italic(Animal), " ", italic("3"))',  parse = T, size = label.size)+
  theme_void()

fig1.left <- (ex.1 / ex.2 / ex.3 / ex.4 / ex.5 / ex.6)


#Rescale data so that it has a mV range 0-1
example.shift <- stims[stims$Protocol %in% c("180110_stim.atf") , ]
example.shift$Seconds <- example.shift$Seconds/1000
example.shift$mV <- example.shift$mV - min(example.shift$mV, na.rm = T)
example.shift$mV <- example.shift$mV / max(example.shift$mV, na.rm = T)

example.shift$Protocol <- "B"
# example.shift$ShiftBy <- 0
examples.shifted <- map(seq_along(c(1, 16, 8, 4, 2)), function(j, temp = example.shift){
  i <- c(1, 16, 8, 4, 2)[j]
  
  if (i == 1){
    temp$Protocol <- "0"
  } else {
    # make shifted times
    shift.by <- floor(nrow(temp) / i)
    temp$Seconds <- c(temp$Seconds[seq(shift.by+1, nrow(temp))], temp$Seconds[seq(1, shift.by)])
    # add ShiftBy so we can make scale bars
    # temp$ShiftBy <- temp[shift.by, "Seconds"]
    # update Protocol name
    temp$Protocol <- as.character((1/i)*360)
  }
  # change min mV so that 
  temp$mV <- temp$mV - j
  
  # since we'll visualize with geom_path we need to sort here.
  temp <- arrange(temp, Seconds)
  
  return(temp)
})

# Grow list
examples.shifted[[length(examples.shifted)+1]] <- example.shift
# collapse into df
example.shift.plt.df <- do.call(rbind, examples.shifted)


period <- max(example.shift.plt.df$Seconds, na.rm = T)

font.size = 2

fig1.right <- ggplot(example.shift.plt.df, aes(Seconds, mV, group = Protocol))+
  # geom_segment(aes(x = 0.71, xend = 0.71,                         y = 1, yend = -1), size = 1, color = "cornflowerblue")+
  geom_segment(aes(x = 0.71+(period/16), xend = 0.71+(period/16), y = 1, yend = -1), size = 1, color = "cornflowerblue")+
  geom_segment(aes(x = 0.71+(period/8),  xend = 0.71+(period/8),  y = 1, yend = -2), size = 1, color = "cornflowerblue")+
  geom_segment(aes(x = 0.71+(period/4),  xend = 0.71+(period/4),  y = 1, yend = -3), size = 1, color = "cornflowerblue")+
  geom_segment(aes(x = 0.71+(period/2),  xend = 0.71+(period/2),  y = 1, yend = -4), size = 1, color = "cornflowerblue")+

  geom_segment(aes(x = 0.71,  xend = 0.71+(period/2),             y = 1, yend = 1), size = 1, color = "cornflowerblue")+
  # annotate("text", x = 0.61, y = 1.1, parse = TRUE, label = as.character(expression(paste(Phi, "=", sep = ""))) )+
  annotate("text", x = 0.71, y = 1.1, parse = TRUE, label = as.character(expression(paste("0", degree, sep = ""))) , size = font.size)+
  annotate("text", x = 0.71+(period/16), y = 1.1, parse = TRUE, label = as.character(expression(paste("22", degree, sep = ""))) , size = font.size)+
  annotate("text", x = 0.71+(period/8), y = 1.1, parse = TRUE, label = as.character(expression(paste("45", degree, sep = ""))) , size = font.size)+
  annotate("text", x = 0.71+(period/4), y = 1.1, parse = TRUE, label = as.character(expression(paste("90", degree, sep = ""))) , size = font.size)+
  annotate("text", x = 0.71+(period/2), y = 1.1, parse = TRUE, label = as.character(expression(paste("180", degree, sep = ""))) , size = font.size)+
  
  geom_path(size = trace.size)+  
  geom_segment(aes(x = 0, xend = 0, y = -5.05, yend = -5.05+((1/20.2529)*10)), size = bar.size)+
  geom_segment(aes(x = 0, xend = 1, y = -5.05, yend = -5.05), size = bar.size)+
  theme_void()

fig1.part <- (fig1.left | fig1.right) + plot_annotation(tag_levels = 'i')




# tea.protocol.fig <- 
# ggplot()+
#   geom_path(data = stims[stims$Protocol %in% c("aberrant_depol_man.atf") , ], aes(Seconds, mV, group = 1))+
#   geom_path(data = stims[stims$Protocol %in% c("aberrant_depol_man_22deg.ATF") , ], aes(Seconds, mV-(39.97*1), group = 1))+
#   geom_segment(aes(x = 0, xend = 0, y = -90, yend = -80), size = 1)+
#   geom_segment(aes(x = 0, xend = 1000, y = -90, yend = -90), size = 1)+
#   theme_void()
# 
# hv.protocol.fig <- 
# ggplot()+
#   geom_path(data = stims[stims$Protocol %in% c("HA_00.ATF") , ], aes(Seconds, mV, group = 1))+
#   geom_path(data = stims[stims$Protocol %in% c("HA_90.ATF") , ], aes(Seconds, mV-(39.97*1), group = 1))+
#   geom_segment(aes(x = 0, xend = 0, y = -90, yend = -80), size = 1)+
#   geom_segment(aes(x = 0, xend = 1, y = -90, yend = -90), size = 1)+
#   theme_void()
# 
# nv.protocol.fig <- 
# ggplot()+
#   geom_path(data = stims[stims$Protocol %in% c("180110_stim.atf") , ], aes(Seconds, mV, group = 1))+
#   geom_path(data = stims[stims$Protocol %in% c("180110_stim_22deg.ATF") , ], aes(Seconds, mV-(20.26*1), group = 1))+
#   geom_path(data = stims[stims$Protocol %in% c("180110_stim_45deg.ATF") , ], aes(Seconds, mV-(20.26*2), group = 1))+
#   geom_path(data = stims[stims$Protocol %in% c("180110_stim_90deg.ATF") , ], aes(Seconds, mV-(20.26*3), group = 1))+
#   geom_segment(aes(x = 0, xend = 0, y = -110, yend = -100), size = 1)+
#   geom_segment(aes(x = 0, xend = 1000, y = -110, yend = -110), size = 1)+
#   theme_void()
# 
# fig1.part <- ((tea.protocol.fig / hv.protocol.fig) | nv.protocol.fig) + plot_annotation(tag_levels = 'i')
```




## Prep Figures 2-4
```{r}
# ## High Volt ====
manual.y1 = -3.7
manual.y2 = 2.1

# plt.tea
inset.w = .22
inset.h = .05

x1 = 0.167
x2 = 0.61

y1 = .825
y2 = .88

plt.tea.a <- ggdraw()+
  draw_plot(plt.tea+ylim(manual.y1, manual.y2)) +
  # lead
  draw_plot(inset_plts$tea0, x = x1, y = y1, width = inset.w, height = inset.h)+
  draw_plot(inset_plts$tea0, x = x2, y = y1, width = inset.w, height = inset.h)+
  # follow
  draw_plot(inset_plts$tea0,   x = x1, y = y2, width = inset.w, height = inset.h)+
  draw_plot(inset_plts$tea22,  x = x2, y = y2, width = inset.w, height = inset.h)

### plot high voltage ####
# inset.w = .24
# inset.h = .05
#
# x1 = 0.1
# x2 = 0.7
#
# y1 = .825
# y2 = .88

plt.hv.a <- ggdraw()+
  draw_plot(plt.hv+ylim(manual.y1, manual.y2)) +
  # lead
  draw_plot(inset_plts$ha0, x = x1, y = y1, width = inset.w, height = inset.h)+
  draw_plot(inset_plts$ha0, x = x2, y = y1, width = inset.w, height = inset.h)+
  # follow
  draw_plot(inset_plts$ha90,   x = x1, y = y2, width = inset.w, height = inset.h)+
  draw_plot(inset_plts$ha90,  x = x2, y = y2, width = inset.w, height = inset.h)

plt.tea.hv.a <- plt.tea.a + plt.hv.a + plot_annotation(tag_levels = 'A')

## Standardized ====

inset.w = .12
inset.h = .05

x1 = 0.085
x2 = 0.32
x3 = 0.555
x4 = 0.792

y1 = .825
y2 = .88

plt.lv.a <- ggdraw()+
  draw_plot(plt.lv) +
  # lead
  draw_plot(inset_plts$s0, x = x1, y = y1, width = inset.w, height = inset.h)+
  draw_plot(inset_plts$s0, x = x2, y = y1, width = inset.w, height = inset.h)+
  draw_plot(inset_plts$s0, x = x3, y = y1, width = inset.w, height = inset.h)+
  draw_plot(inset_plts$s0, x = x4, y = y1, width = inset.w, height = inset.h)+
  # follow
  draw_plot(inset_plts$s0,   x = x1, y = y2, width = inset.w, height = inset.h)+
  draw_plot(inset_plts$s22,  x = x2, y = y2, width = inset.w, height = inset.h)+
  draw_plot(inset_plts$s45,  x = x3, y = y2, width = inset.w, height = inset.h)+
  draw_plot(inset_plts$s90,  x = x4, y = y2, width = inset.w, height = inset.h)


# ## Naturalistic ====

# inset.w = .12
# inset.h = .05
# 
# x1 = 0.075
# x2 = 0.265
# x3 = 0.455
# x4 = 0.645
# x5 = 0.835
# 
# y1 = .815
# y2 = .87
# 
# plt.nv.a <- ggdraw()+
#   draw_plot(plt.nv) +
#   # lead
#   draw_plot(inset_plts$n0, x = x1, y = y1, width = inset.w, height = inset.h)+
#   draw_plot(inset_plts$n0, x = x2, y = y1, width = inset.w, height = inset.h)+
#   draw_plot(inset_plts$n0, x = x3, y = y1, width = inset.w, height = inset.h)+
#   draw_plot(inset_plts$n0, x = x4, y = y1, width = inset.w, height = inset.h)+
#   draw_plot(inset_plts$n0, x = x5, y = y1, width = inset.w, height = inset.h)+
#   # follow
#   draw_plot(inset_plts$n0,   x = x1, y = y2, width = inset.w, height = inset.h)+
#   draw_plot(inset_plts$n22,  x = x2, y = y2, width = inset.w, height = inset.h)+
#   draw_plot(inset_plts$n45,  x = x3, y = y2, width = inset.w, height = inset.h)+
#   draw_plot(inset_plts$n90,  x = x4, y = y2, width = inset.w, height = inset.h)+
#   draw_plot(inset_plts$n180, x = x5, y = y2, width = inset.w, height = inset.h)

indv1 <- stims[stims$Protocol %in% c("170828_lead.atf") , ]
indv2 <- stims[stims$Protocol %in% c("180717a_follow.atf") , ]
indv3 <- stims[stims$Protocol %in% c("180718_lead.atf") , ]



add_shifts_indv <- function(df = indv1){
  df <- cbind(df, data.frame(p0 = NA, p16 = NA, p8 = NA, p4 = NA, p2 = NA))
  df$Seconds <- df$Seconds - min(df$Seconds, na.rm = T)
  df$mV <- df$mV - min(df$mV, na.rm = T)
  
  df$p0 <- df$mV
  df$p16<- c(df$mV[seq(length(df$mV)-(ceiling(length(df$mV) / 16)-1), length(df$mV))], 
             df$mV[seq(1, (length(df$mV)-ceiling(length(df$mV) / 16)))])
  df$p8 <- c(df$mV[seq(length(df$mV)-(ceiling(length(df$mV) / 8)-1), length(df$mV))], 
             df$mV[seq(1, (length(df$mV)-ceiling(length(df$mV) / 8)))])
  df$p4 <- c(df$mV[seq(length(df$mV)-(ceiling(length(df$mV) / 4)-1), length(df$mV))], 
             df$mV[seq(1, (length(df$mV)-ceiling(length(df$mV) / 4)))])
  df$p2 <- c(df$mV[seq(length(df$mV)-(ceiling(length(df$mV) / 2)-1), length(df$mV))], 
             df$mV[seq(1, (length(df$mV)-ceiling(length(df$mV) / 2)))])
  return(df)
}


indv1 <- add_shifts_indv(df = indv1)
indv2 <- add_shifts_indv(df = indv2)
indv3 <- add_shifts_indv(df = indv3)

indvs <- do.call(rbind, list(indv1, indv2, indv3))



indv_inset_2color <- map(c("p0", "p16", "p8", "p4", "p2"), function(i){
  indvs %>% 
    ggplot(aes(x= Seconds, group = "Protocol"))+
    # geom_segment(aes(x = 0, xend = 0, y = 0, yend = 5))+
    geom_path(aes_string(y = i), color = "darkgray")+
    geom_path(aes(y = p0))+
    facet_wrap(.~Protocol, scales = "free_y", 
               ncol = 1)+
    theme_void()+
    theme(strip.text = element_blank())  
})
  
names(indv_inset_2color) <- c("p0", "p16", "p8", "p4", "p2")





inset.w = .12
inset.h = .17

x1 = 0.075
x2 = 0.265
x3 = 0.455
x4 = 0.645
x5 = 0.835

y2 = .7

plt.nv.a <- ggdraw()+
  draw_plot(plt.nv) +
  draw_plot(indv_inset_2color$p0,   x = x1, y = y2, width = inset.w, height = inset.h)+
  draw_plot(indv_inset_2color$p16,  x = x2, y = y2, width = inset.w, height = inset.h)+
  draw_plot(indv_inset_2color$p8,  x = x3, y = y2, width = inset.w, height = inset.h)+
  draw_plot(indv_inset_2color$p4,  x = x4, y = y2, width = inset.w, height = inset.h)+
  draw_plot(indv_inset_2color$p2, x = x5, y = y2, width = inset.w, height = inset.h)

```

### Prototype version 2 of figure 4 
Show variability in traces AND delay

```{r}






```



## Confirm no directionality or rectification

```{r}
M.directionality <- 
M.clean %>% dplyr::select(Condition, Experiment, Time, Inj_Cell, rc, gj) %>% distinct() %>% as_tibble()

M.directionality %>% 
  gather(key = "rec", value = "Resistance", c("rc", "gj")) %>% 
  filter(!is.na(Resistance)) %>% 
  spread(key = "Inj_Cell", value = "Resistance") %>% 
  ggplot(aes(x = LC4, y = LC5, group = Condition, color = Condition, fill = Condition))+
  geom_abline(slope = 1, intercept = 0, color = "black")+
  geom_smooth(method = "lm", fullrange = T)+
  geom_point(shape = 1)+
  xlim(0, 30)+
  ylim(0, 30)+
  facet_grid(Time~Condition)+
  theme(legend.position = "bottom")

```

## Figures for DJS -- What's happening with currents?

```{r}
temp_df <- M.clean[M.clean$Condition %in% c("PS.0.High.Amp", "PS.22", "PS.45", "PS.0", "PS.22.High.Amp", "PS.90", "PS.90.HA", "PS.90.HA.Cd"), ]

# current_DV <- "intercept.peak_htk"


dv_array <- c("intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk",
    "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a")



plt_list_currents <- map(
  dv_array, function(current_DV){
      
      temp_df$DV <- temp_df[[current_DV]]
      
      temp_df %>% 
        dplyr::select(Condition, Experiment, Inj_Cell, Time, DV) %>% 
        group_by(Condition, Experiment, Inj_Cell, Time) %>%
        summarise(DV = mean(DV, na.rm = T)) %>% 
        ungroup() %>% 
        # mutate(Time = as.character(Time)) %>% 
        pivot_wider(names_from = Time, values_from = DV) %>% 
        mutate(`20` = `20` - `0`,
               `40` = `40` - `0`,
               `60` = `60` - `0`) %>% 
        mutate(`0` = 0) %>% 
        pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "DV") %>% 
        group_by(Condition, Time) %>% 
        mutate(mean_DV = mean(DV, na.rm = T),
               mean_sd_up = mean_DV+sd(DV, na.rm = T),
               mean_sd_dn =mean_DV- sd(DV, na.rm = T),) %>% 
        mutate(inter = paste(Experiment, Inj_Cell, sep = ".")) %>% 
        ggplot(aes(x = Time, 
                   y = DV, 
                   # color = Experiment, 
                   # shape = Inj_Cell, 
                   group = inter))+
        geom_ribbon(aes(ymin=mean_sd_dn, ymax=mean_sd_up), fill = "gray", alpha = 0.1)+
        lemon::geom_pointline(size = point.size, linesize = line.size)+
        geom_point(size = point.size)+
        geom_point(aes(x = Time, y = mean_DV), color = "white", size = mean.point.size, alpha = 0.3)+
        geom_pointline(aes(x = Time, y = mean_DV), color = "firebrick", size = mean.point.size, linesize = mean.line.size,  shape = 1)+
        # labs(y = expression(paste(Delta, "Rc", " in M", Omega)), x = "Time in Minutes")+
        facet_grid(.~Condition,
                   labeller = labeller(Condition = condition.labs))+
        geom_hline(yintercept = 0)+
        theme(
          # axis.text = element_text(size = rel(2), angle = 0),
          text = element_text(size=text.size)
        )+
        labs(title = current_DV)
    })





temp_df$Condition <- as.character(temp_df$Condition)
temp_df[temp_df$Condition %in% c("PS.0.High.Amp", "PS.22.High.Amp", "PS.90.HA", "PS.90.HA.Cd"), "Condition"] <- "HighAmp"
temp_df[temp_df$Condition %in% c("PS.22", "PS.45", "PS.0", "PS.90"), "Condition"] <- "LowAmp"

plt_list_currents2 <- map(
  dv_array, function(current_DV){
      
      temp_df$DV <- temp_df[[current_DV]]
      
      temp_df %>% 
        dplyr::select(Condition, Experiment, Inj_Cell, Time, DV) %>% 
        group_by(Condition, Experiment, Inj_Cell, Time) %>%
        summarise(DV = mean(DV, na.rm = T)) %>% 
        ungroup() %>% 
        # mutate(Time = as.character(Time)) %>% 
        pivot_wider(names_from = Time, values_from = DV) %>% 
        mutate(`20` = `20` - `0`,
               `40` = `40` - `0`,
               `60` = `60` - `0`) %>% 
        mutate(`0` = 0) %>% 
        pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "DV") %>% 
        group_by(Condition, Time) %>% 
        mutate(mean_DV = mean(DV, na.rm = T),
               mean_sd_up = mean_DV+sd(DV, na.rm = T),
               mean_sd_dn =mean_DV- sd(DV, na.rm = T),) %>% 
        mutate(inter = paste(Experiment, Inj_Cell, sep = ".")) %>% 
        ggplot(aes(x = Time, 
                   y = DV, 
                   # color = Experiment, 
                   # shape = Inj_Cell, 
                   group = inter))+
        geom_ribbon(aes(ymin=mean_sd_dn, ymax=mean_sd_up), fill = "gray", alpha = 0.1)+
        lemon::geom_pointline(size = point.size, linesize = line.size)+
        geom_point(size = point.size)+
        geom_point(aes(x = Time, y = mean_DV), color = "white", size = mean.point.size, alpha = 0.3)+
        geom_pointline(aes(x = Time, y = mean_DV), color = "firebrick", size = mean.point.size, linesize = mean.line.size,  shape = 1)+
        # labs(y = expression(paste(Delta, "Rc", " in M", Omega)), x = "Time in Minutes")+
        facet_grid(.~Condition
                   # ,
                   # labeller = labeller(Condition = condition.labs)
                   )+
        geom_hline(yintercept = 0)+
        theme(
          # axis.text = element_text(size = rel(2), angle = 0),
          text = element_text(size=text.size)
        )+
        labs(title = current_DV)
    })






walk(seq_along(dv_array), function(i){
  current_DV <- dv_array[i]

ggsave(plt_list_currents2[[i]], path = here("data", "figures"),
       filename = paste("DJS_VC_Join-", current_DV, ".tiff", sep = ""))

ggsave(plt_list_currents[[i]], path = here("data", "figures"),
       filename = paste("DJS_VC_Sept-", current_DV, ".tiff", sep = ""))
})




temp_df_lc_similarity <- temp_df %>% dplyr::filter(Time == 0) 



dv_array2 <- c("r11", "r12", "r1", "rc", "cc", "rmp", "gj", 
               "gj", # <--- just a placeholder 
               "intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk", "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a")

similarity_plts <- map(seq_along(dv_array2), function(i){
  current_DV <- dv_array2[i]
  
  temp_df_lc_similarity$DV <- temp_df_lc_similarity[[current_DV]]
  
  plt <- 
    temp_df_lc_similarity %>% 
    dplyr::select(Experiment, Inj_Cell, DV) %>% 
    dplyr::filter(!is.na(DV)) %>% 
    # spread(Inj_Cell, DV) %>% 
    ggplot(aes(x = Inj_Cell, y = DV, group = Experiment))+
    geom_line()+
    geom_point()+
    labs(title =  current_DV, x = "", y = "")
  
  if (current_DV=="rc"){
    plt <- 
      temp_df_lc_similarity %>% 
      dplyr::select(Experiment, Inj_Cell, DV) %>% 
      dplyr::filter(!is.na(DV)) %>% 
      dplyr::filter(DV < 20) %>% 
      # spread(Inj_Cell, DV) %>% 
      ggplot(aes(x = Inj_Cell, y = DV, group = Experiment))+
      geom_line()+
      geom_point()+
      labs(title =  current_DV, x = "", y = "")
  }
  
  return(plt)
})


similarity_plts[[8]] <- NA


# cowplot::plot_grid(plotlist = similarity_plts)

ggsave(cowplot::plot_grid(plotlist = similarity_plts), path = here("data", "figures"),
       filename = paste("DJS_LC_Similarity.tiff", sep = ""), width = 12, height = 12
       
       )












similarity_plts2 <- map(seq_along(dv_array2), function(i){
  current_DV <- dv_array2[i]
  
  temp_df_lc_similarity$DV <- temp_df_lc_similarity[[current_DV]]
  
  resample_iters = 1000
  
  real_diffs <- temp_df_lc_similarity %>% 
    dplyr::select(Experiment, Inj_Cell, DV) %>% 
    dplyr::filter(!is.na(DV)) %>% 
    spread(Inj_Cell, DV) %>% 
    dplyr::filter(!is.na(LC4)) %>% 
    dplyr::filter(!is.na(LC5)) %>% 
    mutate(DV_Diff = LC4-LC5) %>% 
    mutate(iter = 0, real = T) %>% 
    dplyr::select(Experiment, DV_Diff, iter, real)
  
  fake_diffs <- map(1:resample_iters, function(i){
    temp <- temp_df_lc_similarity
    
    # temp$inter <- paste(temp$Experiment, temp$Inj_Cell, sep = ".")
    # 
    # temp$inter <- sample(temp$inter, replace = F)
    # 
    # new_labels <- temp$inter %>% str_split(pattern = "\\.") %>% transpose()
    # 
    # temp$Experiment <- unlist(new_labels[[1]])
    # temp$Inj_Cell <- unlist(new_labels[[2]])
    
    temp <- temp %>% 
      dplyr::select(Experiment, Inj_Cell, DV) %>% 
      dplyr::filter(!is.na(DV)) %>% 
      spread(Inj_Cell, DV) %>% 
      dplyr::filter(!is.na(LC4)) %>% 
      dplyr::filter(!is.na(LC5)) %>% 
      gather(Inj_Cell, DV, c("LC4", "LC5"))
    
    temp$DV <- sample(temp$DV)
    
    temp %>% 
      spread(Inj_Cell, DV) %>%
      mutate(DV_Diff = LC4-LC5) %>% 
      mutate(iter = i, real = F) %>% 
      dplyr::select(Experiment, DV_Diff, iter, real)
  })
  
  compare_diffs <- rbind(real_diffs, do.call(rbind, fake_diffs))
  
  plt_a <- 
    compare_diffs %>% 
    ggplot(aes(x = DV_Diff, fill = real, color = real))+
    geom_vline(xintercept = 0, linetype = "dashed")+
    geom_density(alpha = 0.5)+
    labs(title =  current_DV, x = "", y = "")+
    theme(legend.position = "bottom")
  
  plt_b <- 
    compare_diffs %>% 
    ggplot(aes(x = DV_Diff, color = real))+
    stat_ecdf()+
    labs(title =  current_DV, x = "", y = "")+
    theme(legend.position = "bottom")
  
  # plt  <- plt_a + plt_b
  # return(plt)
  return(list(plt_a, plt_b))
})



similarity_plts2[[8]] <- list(NA, NA)


similarity_plts2 <- transpose(similarity_plts2)

ggsave(cowplot::plot_grid(plotlist = similarity_plts2[[1]], ncol = 4), path = here("data", "figures"),
filename = paste("DJS_LC_Similarity_density.tiff", sep = ""),
width = 12, height = 12
)

ggsave(cowplot::plot_grid(plotlist = similarity_plts2[[2]], ncol = 4), path = here("data", "figures"),
filename = paste("DJS_LC_Similarity_ecdf.tiff", sep = ""),
width = 12, height = 12
)

# ggsave(cowplot::plot_grid(plotlist = list(
#   similarity_plts2[[1]], 
#   similarity_plts2[[2]], 
#   similarity_plts2[[3]], 
#   similarity_plts2[[4]], 
#   similarity_plts2[[5]], 
#   similarity_plts2[[6]], 
#   similarity_plts2[[7]], 
#   NA,
#   similarity_plts2[[8]], 
#   similarity_plts2[[9]], 
#   similarity_plts2[[10]], 
#   similarity_plts2[[11]], 
#   similarity_plts2[[12]], 
#   similarity_plts2[[13]], 
#   similarity_plts2[[14]], 
#   similarity_plts2[[15]], 
#   similarity_plts2[[16]]
# ), ncol = 4), path = here("data", "figures"),
# filename = paste("DJS_LC_Similarity_ecdf.tiff", sep = ""), 
# width = 12, height = 12
# 
# )






```

### What are the relationships between the trajectories?
```{r}
df <- M.clean[M.clean$Condition %in% c("PS.0.High.Amp", "PS.22", "PS.45", "PS.0", "PS.22.High.Amp", "PS.90", "PS.90.HA", "PS.90.HA.Cd"), ]

# current_DV <- "intercept.peak_htk"


dvs_for_delta <- c("r11", "r12", "r1", "rc", "cc", "rmp", "gj", 
               "intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk", "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a")

temp_delta_list <- map(
  dvs_for_delta, function(current_DV){
      temp_df <- df
      temp_df$DV <- temp_df[[current_DV]]
      
      temp_df <- temp_df %>% 
        dplyr::select(Condition, Experiment, Inj_Cell, Time, DV) %>% 
        group_by(Condition, Experiment, Inj_Cell, Time) %>%
        summarise(DV = mean(DV, na.rm = T)) %>% 
        ungroup() %>% 
        # mutate(Time = as.character(Time)) %>% 
        pivot_wider(names_from = Time, values_from = DV) %>% 
        mutate(`20` = `20` - `0`,
               `40` = `40` - `0`,
               `60` = `60` - `0`) %>% 
        mutate(`0` = 0) %>% 
        pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "DV") %>% 
        group_by(Condition, Time) #%>% 
        # mutate(mean_DV = mean(DV, na.rm = T),
        #        mean_sd_up = mean_DV+sd(DV, na.rm = T),
        #        mean_sd_dn =mean_DV- sd(DV, na.rm = T),) %>% 
        # mutate(inter = paste(Experiment, Inj_Cell, sep = ".")) %>% 
        # ggplot(aes(x = Time, 
        #            y = DV, 
        #            # color = Experiment, 
        #            # shape = Inj_Cell, 
        #            group = inter))+
        # geom_ribbon(aes(ymin=mean_sd_dn, ymax=mean_sd_up), fill = "gray", alpha = 0.1)+
        # lemon::geom_pointline(size = point.size, linesize = line.size)+
        # geom_point(size = point.size)+
        # geom_point(aes(x = Time, y = mean_DV), color = "white", size = mean.point.size, alpha = 0.3)+
        # geom_pointline(aes(x = Time, y = mean_DV), color = "firebrick", size = mean.point.size, linesize = mean.line.size,  shape = 1)+
        # # labs(y = expression(paste(Delta, "Rc", " in M", Omega)), x = "Time in Minutes")+
        # facet_grid(.~Condition,
        #            labeller = labeller(Condition = condition.labs))+
        # geom_hline(yintercept = 0)+
        # theme(
        #   # axis.text = element_text(size = rel(2), angle = 0),
        #   text = element_text(size=text.size)
        # )+
        # labs(title = current_DV)
      
      names(temp_df)[names(temp_df) == "DV"] <- current_DV
      
      return(temp_df)
    })

#

df2 <- temp_delta_list[[1]]
for (i in seq(2, length(temp_delta_list))){
  df2 <- full_join(df2, temp_delta_list[[i]])
}

plt1 <- 
df2 %>% filter(Time %in% c(40)) %>% 
  dplyr::filter(!(Condition %in% c("PS.90.HA", "PS.90.HA.Cd"))) %>% 
  gather(Current, Value, c("intercept.peak_htk", "intercept.end_htk", "intercept.peak_a", "intercept.end_a"#,
                           # "slope.peak_htk", "slope.end_htk", "slope.peak_a", "slope.end_a"
                           )) %>% 
  ggplot(aes(gj, Value, color = Condition, fill = Condition))+
  geom_hline(yintercept = 0, color = "darkgrey")+
  geom_vline(xintercept = 0, color = "darkgrey")+
  # geom_smooth(method = "lm", se = T, fullrange = T)+
  geom_point()+
  geom_point(shape = 1, color = "black")+
  facet_grid(Current~Condition)+
  # facet_wrap(Current~Condition, scales = "free")+
  theme(legend.position = "")+
  coord_cartesian(y = c(-100, 100))

plt2 <- 
df2 %>% filter(Time %in% c(40)) %>% 
  dplyr::filter(!(Condition %in% c("PS.90.HA", "PS.90.HA.Cd"))) %>% 
  gather(Current, Value, c(#"intercept.peak_htk", "intercept.end_htk", "intercept.peak_a", "intercept.end_a",
                           "slope.peak_htk", "slope.end_htk", "slope.peak_a", "slope.end_a"
                           )) %>% 
  ggplot(aes(gj, Value, color = Condition, fill = Condition))+
  geom_hline(yintercept = 0, color = "darkgrey")+
  geom_vline(xintercept = 0, color = "darkgrey")+
  # geom_smooth(method = "lm", se = T, fullrange = T)+
  geom_point()+
  geom_point(shape = 1, color = "black")+
  facet_grid(Current~Condition)+
  # facet_wrap(Current~Condition, scales = "free")+
  theme(legend.position = "")





plt1 + plt2
```




## Reference figures from resampling
```{r eval=FALSE, include=FALSE}
### reference plots using the exact data that went into our test ####
furrr::future_map(seq(1, nrow(all.tests)), function(i){
  condition.labs <- c("TEA Mimic Sync", "TEA Mimic Async", "Depol. Async", "Depol. Async Cd2+",
                      "Low mV 0 Deg.", "Low mV 22.5 Deg.", "Low mV 45 Deg.", "Low mV 90 Deg.",
                      "Natural 0 Deg.", "Natural 22.5 Deg.", "Natural 45 Deg.", "Natural 90 Deg.", "Natural 180 Deg.")
  
  names(condition.labs) <- c("PS.0.High.Amp", "PS.22.High.Amp", "PS.90.HA", "PS.90.HA.Cd",
                             "PS.0", "PS.22", "PS.45", "PS.90",
                             "PS.0.orig", "PS.22.orig", "PS.45.orig", "PS.90.orig", "PS.180.orig")
  
  plt <- prepped.df[[i]] %>% 
    dplyr::select(Condition, Experiment, Time, dept.var) %>% 
    group_by(Condition, Experiment, Time) %>%
    summarise(dept.var = mean(dept.var, na.rm = T)) %>% 
    ungroup() %>% 
    
    # mutate(Time = as.character(Time)) %>% 
    pivot_wider(names_from = Time, values_from = dept.var) %>% 
    mutate(`20` = `20` - `0`,
           `40` = `40` - `0`,
           `60` = `60` - `0`) %>% 
    mutate(`0` = 0) %>% 
    pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "dept.var") %>% 
    group_by(Condition, Time) %>% 
    mutate(mean_dept.var = mean(dept.var, na.rm = T),
           mean_sd_up = mean_dept.var+sd(dept.var, na.rm = T),
           mean_sd_dn =mean_dept.var- sd(dept.var, na.rm = T),) %>% 
    mutate(inter = paste(Experiment, sep = ".")) %>% 
    ggplot(aes(x = Time, 
               y = dept.var, 
               # color = Experiment, 
               # shape = Inj_Cell, 
               group = inter))+
    geom_ribbon(aes(ymin=mean_sd_dn, ymax=mean_sd_up), fill = "gray", alpha = 0.1)+
    lemon::geom_pointline()+
    geom_point()+
    geom_point(aes(x = Time, y = mean_dept.var), color = "white", size = 2, alpha = 0.3)+
    geom_pointline(aes(x = Time, y = mean_dept.var), color = "firebrick", size = 2, shape = 1)+
    # labs(y = expression(paste(Delta, "Rc", " in M", Omega)), x = "Time in Minutes")+
    labs(y = as.character(all.tests.list[[i]][, "DV"]))+
    facet_grid(.~Condition,
               labeller = labeller(Condition = condition.labs))+
    geom_hline(yintercept = 0)+
    theme_minimal()
  
  
  file.name <- paste0(as.character(all.tests[i, "DV"]),
                      "-",
                      as.character(all.tests[i, "Groups"]),
                      ".tiff")
  
  ggsave(filename = here("data", "figures", "match_tests", file.name), plot = plt)
  return(i)
  
})
```




# Reorganizing alternate predictors for naturalistic stim
```{r}
library(tidyverse)
library(zoo)

# Really just a wrapper for loadABF()
readABF_as_matrix <- function(
  path = "",
  channels = c("IN 4", "IN 9")){

  trace <- readABF::readABF(file = path)

  start.time <- trace$header$recTime[1]
  end.time <- trace$header$recTime[2]
  obs <- nrow(trace$data[[1]])

  temp <- trace$data[[1]][, (trace$channelNames %in% channels)]
  temp <- as.matrix(temp)

  colnames(temp) <- trace$channelNames[trace$channelNames %in% channels]
  temp <- cbind(temp, Time = seq(from = start.time,
                                 to = end.time,
                                 length.out = obs))

  return(temp)
}



# traces %>% stringr::str_detect(pattern = ".abf")
# 
# traces %>% stringr::str_detect(pattern = ".atf")
# traces %>% stringr::str_detect(pattern = ".ATF")
# 
# 
# abf_version <- readABF_as_matrix(path = here("inst", "extdata", "orig_waveforms", "180717a_0013.abf"),
#                                  channels = c("IN 4", "IN 9"))
# 
# head(abf_version)

# atf_version <- read.table(here("inst", "extdata", "orig_waveforms", "HA_90.ATF"))
# 
# head(atf_version)

# traces <- map(c("180221_0029", "180308_0013", "180425_0017", "180510_0034", "180604_0009", "190408_0026", "191209_0011"), function(i){


```
 
```{r}
traces <- list.files(here::here("inst", "extdata", "orig_waveforms"))

## load in traces, make them into dfs, and give them names equal to their file names ====
stim <- map(traces, function(i){
  readABF_as_matrix(
  path = paste0(here::here("inst", "extdata", "orig_waveforms"), "/", i),
  channels = c("IN 4", "IN 9"))
})
names(stim) <- traces
stim <- plyr::ldply(stim, data.frame)
stim <- rename(stim, Trace = .id)

## find the start time for each trace and adjust the mime of each so all begin at 0 ====
min.times <- stim %>% group_by(Trace) %>% summarise(min(Time))

stim$min.time <- NA
walk(seq(from = 1, to = nrow(min.times)), 
     function(i){
       stim[stim$Trace == as.character(min.times[i, "Trace"]), "min.time"] <<- as.numeric(min.times[i, 2])
     })

stim <- stim %>% mutate(Time = Time - min.time) %>% gather(Ch, mV, c("IN.4", "IN.9"))

## Remove any artifacts ====
#large artifact in 180717a_0013.abf between 4.918, 4.926. Replace with values at 4.918
# replace.vals <- stim %>% ungroup() %>% filter(Trace == "180717a_0013.abf", Time == 0) %>% group_by(Ch)
stim[stim$Trace == "180717a_0013.abf" & (stim$Time > 4.918 & stim$Time < 4.926), "mV"] <- -56.0


## Smooth ====
stim <- stim %>% 
  ungroup() %>% 
  group_by(Trace, Ch) %>% 
  mutate(mV.f = zoo::rollmean(x = mV, k = 5, fill = "extend")) %>%
  mutate(ID = paste(Ch, Trace)) %>%
  ungroup()
  

### The diversity of traces used ####
# stim %>%
#   # filter(Trace == "180717a_0013.abf") %>%
#   ggplot(aes(Time, mV.f, group = ID, color = Trace))+
#   geom_line(alpha = 0.6)+
#   facet_grid(.~Ch)+
#   theme(legend.position = "")


# See the standardized protocols to pair them with ####
# "180221_0029.abf", "TEA sync",
# "180308_0013.abf", "b",
# "180425_0017.abf", "c",
# "180510_0034.abf", "a", 
# "180604_0009.abf", "TEA async",
# "190408_0026.abf", "d",
# "191209_0011.abf", "HA 90"

# stim[stim$Trace %in% c("180221_0029.abf", 
#                        "180308_0013.abf", 
#                        "180425_0017.abf", 
#                        "180510_0034.abf", 
#                        "180604_0009.abf", 
#                        "190408_0026.abf", 
#                        "191209_0011.abf"),  ] %>%
#   ggplot(aes(Time, mV.f, group = ID, color = Ch))+
#   geom_line(alpha = 0.6)+
#   facet_grid(Trace~.)+
#   theme(legend.position = "")




one.trace <- stim %>%
  # filter(Trace %in% c("170710_0037.abf", "180718a_0009.abf")) %>% #FIXME When ready, remove to put all through
  dplyr::select(-min.time,  -ID, -mV) %>%
  spread(Ch, mV.f)


### Once again, lots of crazy variation ####
# one.trace %>% ggplot(aes(group = Trace))+
#   geom_line(aes(x = Time, y = IN.4), color = "Steelblue")+
#   geom_line(aes(x = Time, y = IN.9), color = "Firebrick")


### We can see the overlap/lack of same here. We should get a unity line when there is no differnce in the stimulus.
# one.trace %>% ggplot()+
#   geom_path(aes(x = IN.4, y = IN.9, color = Time))


```

For summary plot later
```{r}
plt.trace.variation <- one.trace



```



```{r}
# First pass at annotation ----

# one.trace %>% ggplot()+
#   geom_line(aes(x = Time, y = IN.4), color = "Steelblue")+
#   geom_line(aes(x = Time, y = IN.9), color = "Firebrick")+
#   geom_hline(yintercept = min(one.trace$IN.4, na.rm = T), color = "Steelblue")+
#   geom_hline(yintercept = min(one.trace$IN.9, na.rm = T), color = "Firebrick")


# one.trace %>%
#   # Voltage difference
#   mutate(diff = IN.4 - IN.9) %>% # Not really useful atm
#   mutate(intersect.V = ifelse( # lower of the two, used for overlap
#     IN.4 <= IN.9,
#     IN.4, IN.9
#     )
#     ) %>%
#     mutate(union.V = ifelse( # Higher of the two.
#     IN.4 >= IN.9,
#     IN.4, IN.9
#     )
#     ) %>%
#   mutate(higher.V.min = ifelse(
#     min(one.trace$IN.4, na.rm = T) >= min(one.trace$IN.9, na.rm = T),
#      min(one.trace$IN.4, na.rm = T),
#      min(one.trace$IN.9, na.rm = T)
#   )) %>%
#   mutate(Overlap.V =  intersect.V - higher.V.min) %>%
#   ggplot()+
#   geom_line(aes(x = Time, y = Overlap.V))+
#   geom_ribbon(aes(x = Time, ymin=min(Overlap.V), ymax=Overlap.V))+
#   geom_line(aes(x = Time, y = IN.4 - min(one.trace$IN.4, na.rm = T)),
#             color = "Steelblue",
#             size = 1)+
#   geom_line(aes(x = Time, y = IN.9 - min(one.trace$IN.9, na.rm = T)),
#             color = "Firebrick",
#             size = 1)

# geom_line(aes(x = Time, y = IN.4), color = "Steelblue")+
# geom_line(aes(x = Time, y = IN.9), color = "Firebrick")
# geom_hline(yintercept = min(one.trace$IN.4, na.rm = T), color = "Steelblue")+
# geom_hline(yintercept = min(one.trace$IN.9, na.rm = T), color = "Firebrick")

# geom_line(aes(x = Time, y = IN.4 - min(one.trace$IN.4, na.rm = T)), color = "Steelblue")+
# geom_line(aes(x = Time, y = IN.9 - min(one.trace$IN.9, na.rm = T)), color = "Firebrick")+
# geom_line(aes(x = Time, y = diff))

# Second pass at annotation ----

## Group by trace and add possible predictors to it ====

### min, baseline, max, median, and mean mV, and duration (period) ####
one.trace <-
  one.trace %>%
  ungroup() %>%
  gather(Ch, mV, c("IN.4", "IN.9")) %>%
  group_by(Trace, Ch) %>%
  # Min Voltage
  mutate(Min.V = min(mV, na.rm = T)) %>%
  # Baseline voltage
  # Defining as average of the lowest 20% of points
  mutate(Use.in.Base = quantile(mV, probs = .2, na.rm = T)) %>%
  mutate(Use.in.Base = ifelse(mV <= Use.in.Base,
    mV,
    NA
  )) %>%
  mutate(Use.in.Base = mean(Use.in.Base, na.rm = T)) %>%
  # Max voltage
  mutate(Max.V = max(mV, na.rm = T)) %>%
  # Median Voltage
  mutate(Med.V = median(mV, na.rm = T)) %>%
  # Mean Voltage
  mutate(Mean.V = mean(mV, na.rm = T)) %>%
  # Duration
  mutate(Max.Time = max(Time, na.rm = T))

### Delay between channels ####
# Get time at which voltage traces cross a threshold. Then compute the abs(difference)
delays.to.annotate <- one.trace %>%
  mutate(Delay = (mV >= quantile(mV, probs = .9, na.rm = T))) %>%
  filter(Delay == T) %>%
  summarise(
    Thres.Time.b = min(Time, na.rm = T),
    Thres.Time.e = max(Time, na.rm = T)
  )

one.trace$Onset <- NA
one.trace$Termination <- NA
walk(seq(1, nrow(delays.to.annotate)), function(i) {
  one.trace[
    one.trace$Trace == as.character(delays.to.annotate[i, "Trace"]) &
      one.trace$Ch == as.character(delays.to.annotate[i, "Ch"]),
    "Onset"
  ] <<- as.numeric(delays.to.annotate[i, "Thres.Time.b"])

  one.trace[
    one.trace$Trace == as.character(delays.to.annotate[i, "Trace"]) &
      one.trace$Ch == as.character(delays.to.annotate[i, "Ch"]),
    "Termination"
  ] <<- as.numeric(delays.to.annotate[i, "Thres.Time.e"])
})

### Add in On duration, Duty Cycle, and AUC ####
one.trace <- one.trace %>%
  # On duration
  mutate(On.Duration = Termination - Onset) %>%
  # Duty Cycle
  mutate(Duty.Cycle = On.Duration / Max.Time) %>%
  # AUC
  # Using Min.V
  mutate(AUC = (mV - Min.V))


## make a list with more user friendly names ====

# Each elemen tof the list consists of only one channel.
one.trace.list <- map(c("IN.4", "IN.9"), function(i) {
  temp <- filter(one.trace, Ch == i)

  temp.names <- names(temp)

  temp.names[!(temp.names %in% c("Trace", "Time", "Ch"))] <-
    paste(temp.names[!(temp.names %in% c("Trace", "Time", "Ch"))], i, sep = "_")

  names(temp) <- temp.names

  temp %>% ungroup()

  return(temp)
})

# put the channels back together
one.trace <- full_join(
  one.trace.list[[1]],
  one.trace.list[[2]],
  by = c("Trace", "Time")
)


##add in delay for each channel (if it starts first it's 0), percent delay, corrlation between channels, and intersectional overlap between channels ==== 
one.trace <- one.trace %>%
  dplyr::group_by(Trace) %>%
  # Delay
  mutate(Delay_IN.4 = ifelse(
    Onset_IN.4 <= Onset_IN.9,
    0,
    Onset_IN.4 - Onset_IN.9
  )) %>%
  mutate(Delay_IN.9 = ifelse(
    Onset_IN.9 <= Onset_IN.4,
    0,
    Onset_IN.9 - Onset_IN.4
  )) %>%
  # Percent Delay (can be converted into phase)
  mutate(P.Delay_IN.4 = Delay_IN.4 / Max.Time_IN.4) %>%
  mutate(P.Delay_IN.9 = Delay_IN.9 / Max.Time_IN.9) %>%
  # Correlation
  mutate(Cor = cor(mV_IN.4, mV_IN.9,
    use = "pairwise.complete.obs",
    method = "pearson"
  )) %>%
  # intersect AUC / % overlap
  mutate(Min.AUC = ifelse(AUC_IN.4 <= AUC_IN.9,
    AUC_IN.4,
    AUC_IN.9
  ))


## show that min AUC is acting as expected ====
# one.trace %>%
#   ggplot(aes(group = Trace)) +
#   geom_line(aes(x = Time, y = mV_IN.4 - Min.V_IN.4), color = "Blue", alpha = 0.4) +
#   geom_line(aes(x = Time, y = mV_IN.9 - Min.V_IN.9), color = "Red", alpha = 0.4) +
#   geom_line(aes(x = Time, y = Min.AUC), color = "Purple") +
#   facet_grid(. ~ Trace)
```


```{r}
## Get summary of all ====

# 1. Get single value descriptors for each trace
one.trace  <- one.trace %>% 
  ungroup() %>% 
  dplyr::group_by(Trace) %>% 
  # Voltages
  mutate(Mean.Min.V = mean(mean(Min.V_IN.4, na.rm = T), mean(Min.V_IN.9, na.rm = T))) %>% 
  mutate(Mean.Max.V = mean(mean(Max.V_IN.4, na.rm = T), mean(Max.V_IN.9, na.rm = T))) %>% 
  mutate(Mean.Med.V = mean(mean(Med.V_IN.4, na.rm = T), mean(Med.V_IN.9, na.rm = T))) %>% 
  mutate(Mean.Mean.V = mean(mean(Mean.V_IN.4, na.rm = T), mean(Mean.V_IN.9, na.rm = T))) %>% 
  
  # Times
  mutate(Mean.Duration = mean(mean(Max.Time_IN.4, na.rm = T), mean(Max.Time_IN.9, na.rm = T))) %>%
  mutate(Mean.On.Duration = mean(mean(On.Duration_IN.4, na.rm = T), mean(On.Duration_IN.9, na.rm = T))) %>% 
  mutate(Mean.Duty.Cycle = mean(mean(Duty.Cycle_IN.4, na.rm = T), mean(Duty.Cycle_IN.9, na.rm = T))) %>% 
  
  mutate(Onset.Delay = max(Delay_IN.4, Delay_IN.9, na.rm = T)) %>% 
  mutate(P.Onset.Delay = max(P.Delay_IN.4, P.Delay_IN.9, na.rm = T)) %>% 
  
  # AUCs -- convert to single value of mV/trace
  mutate(Mean.AUC = mean(sum(AUC_IN.4, na.rm = T), sum(AUC_IN.9, na.rm = T))) %>% 
  mutate(Min.AUC = sum(Min.AUC, na.rm = T)) %>% 
  ## and mV/S
  mutate(Mean.AUC.mV.S = Mean.AUC/Mean.Duration) %>%
  mutate(Min.AUC.mV.S = Min.AUC/Mean.Duration) %>%

  # Clean up selection
  dplyr::select(Trace, #Time, 
                Mean.Min.V, Mean.Max.V, Mean.Med.V, Mean.Mean.V, 
                Mean.Duration, Mean.On.Duration, Mean.Duty.Cycle, 
                Onset.Delay, P.Onset.Delay,
                Mean.AUC, Min.AUC, 
                Mean.AUC.mV.S, Min.AUC.mV.S,
                Cor) %>% ungroup()
 
# 2. Remove the duplicate measures.  
one.trace <- one.trace[!(duplicated(one.trace)), ] 

# 3. Join with gj change datasets
## get the OG dataset ====
# Orig <- M.clean %>% 
Orig <- M.d %>%
  dplyr::filter(Condition %in% c("PS.0.orig",     
                                 "PS.22.orig",   
                                 "PS.45.orig",   
                                 "PS.90.orig",
                                 "PS.180.orig"))
Orig.exps <- Orig$Experiment %>% unique()

## get the standardized dataset ====
Standard <- M.d %>% 
  dplyr::filter(Condition %in% c("PS.0.High.Amp", 
                                 "PS.22.High.Amp", 
                                 "PS.90.HA",
                                 "PS.0", 
                                 "PS.22", 
                                 "PS.45", 
                                 "PS.90"))

## Make trace names join-able ====
new.Trace.names <- stringr::str_split(one.trace$Trace, pattern = "_0") %>% 
  map(function(i){
    pluck(i,1)
  }) %>% unlist()

# Manually fix two
# Orig.exps[!(Orig.exps %in% new.Trace.names)]
# new.Trace.names[!(new.Trace.names %in% Orig.exps)]
new.Trace.names[new.Trace.names == "171016_B"] <- "171016"
new.Trace.names[new.Trace.names == "171017_A"] <- "171017"

one.trace <- one.trace %>% mutate(Experiment = new.Trace.names)


## Produce New Datasets ====
one.trace.orig <- one.trace[!(one.trace$Trace %in% 
                                c("180221_0029.abf", 
                                  "180308_0013.abf",
                                  "180425_0017.abf",
                                  "180510_0034.abf",
                                  "180604_0009.abf",
                                  "190408_0026.abf",
                                  "191209_0011.abf")), ]

one.trace.standard <- one.trace[one.trace$Trace %in% 
                                  c("180221_0029.abf", 
                                    "180308_0013.abf",
                                    "180425_0017.abf",
                                    "180510_0034.abf",
                                    "180604_0009.abf",
                                    "190408_0026.abf",
                                    "191209_0011.abf"), ]

one.trace.standard$Condition <- NA
one.trace.standard[one.trace.standard$Trace == "180221_0029.abf", "Condition"] <- "PS.0.High.Amp"
one.trace.standard[one.trace.standard$Trace == "180308_0013.abf", "Condition"] <- "PS.22"
one.trace.standard[one.trace.standard$Trace == "180425_0017.abf", "Condition"] <- "PS.45"
one.trace.standard[one.trace.standard$Trace == "180510_0034.abf", "Condition"] <- "PS.0"
one.trace.standard[one.trace.standard$Trace == "180604_0009.abf", "Condition"] <- "PS.22.High.Amp"
one.trace.standard[one.trace.standard$Trace == "190408_0026.abf", "Condition"] <- "PS.90"
one.trace.standard[one.trace.standard$Trace == "191209_0011.abf", "Condition"] <- "PS.90.HA"



Orig <- full_join(Orig, one.trace.orig, by = "Experiment")

Standard <- full_join(Standard, one.trace.standard, by = "Condition")
```

Version 1 of the figure displaying individualized data.

```{r}
# plt.trace.variation <- plt.trace.variation[plt.trace.variation$Trace %in% unique(plt.trace.variation$Trace)[c(1,2,4,11,14,#17,19,
#                                                                                                               20,21,26)], ]


plt.trace.variation <- plt.trace.variation[!(plt.trace.variation$Trace %in% 
                                c("180221_0029.abf", 
                                  "180308_0013.abf",
                                  "180425_0017.abf",
                                  "180510_0034.abf",
                                  "180604_0009.abf",
                                  "190408_0026.abf",
                                  "191209_0011.abf")),]

# Add in labels for facetting
temp <- Orig %>% dplyr::select(Condition, Experiment#, Mean.Duration, Mean.On.Duration
                               ) %>% rename(Trace = Experiment) %>% distinct() 



# which experiments use the same stim protocol?
temp1 <- left_join(mutate(plt.trace.variation, Trace = unlist(transpose(str_split(plt.trace.variation$Trace, "_"))[[1]]) ) , temp) %>% dplyr::select(-Condition)

temp1 %>% 
  group_by(Trace) %>% 
  summarise(Duration = max(Time)) %>% arrange(Duration)
	
#     Trace   Duration
# 1	  170623b	2.799864

# 2	  170803b	3.165165

# 3	  170825a	3.200130
# 4	  170925A	3.200130

# 5	  170705a	3.240090
# 6  	170710	3.240090
# 7  	170711e	3.240090

# 8	  170814b	4.300029

# 9	  170808a	4.399929
# 10	170808b	4.399929
# 11	170811	4.399929
# 12	171016	4.399929
# 13	171017	4.399929
# 14	171201	4.399929

# 15	180717a	5.000000

# 16	170828a	5.200128
# 17	180717	5.200128

# 18	170728a	5.435892
# 19	170801a	5.435892
# 20	170802a	5.435892
# 21	170803a	5.435892

# 22	180718	5.660000
# 23	180718a	5.660000

# 24	170817b	5.900094

# 25	170713b	6.216777

# 26	170824a	9.300024



temp1 %>% 
  filter(Trace %in% c(
    # "170623b", "170803b", 
    # "170825a", "170925A", #same stim
    # "170705a", "170710", #same stim
                 "170711e",
               
    # "170814b", 
    # "170808a", "170808b",  "170811",  # Same Stim
                 "171016",  "171017",  "171201" #(171016 and 171201 look to be the same but the clamp on the latter is much worse -- unlikely that it acts as the same stim. Code it as a separate variable?)
    # "180717a", 
    # "170828a", "180717"  # Same Stim
    # "170728a", "170801a", "170802a", "170803a", #same stim
    # "180718",  "180718a"#same stim
    # "170817b", "170713b", "170824a"
  )) %>% 
  group_by(Trace) %>% 
  mutate(Duration = round(max(Time), digits = 2)) %>% 
  gather(key = Ch, value = mV, c("IN.4", "IN.9")) %>% 
  ggplot()+
  geom_line(aes(x = Time, y = mV, group = Trace, color = as.character(Duration)))+
  facet_grid(Trace~Ch)+
  theme(legend.position = "")



```

First test of showing individualized phase
```{r}
# denomerator <- 16
for (denomerator in c(16, 8, 4, 2)){

temp2 <- left_join(mutate(plt.trace.variation, Trace = unlist(transpose(str_split(plt.trace.variation$Trace, "_"))[[1]]) ) , temp)

# time.tol <- 0.01
# temp2[(temp2$Mean.Duration > 3.24-time.tol & temp2$Mean.Duration < 3.24+time.tol) |
#         (temp2$Mean.Duration > 5.900094-time.tol & temp2$Mean.Duration < 5.900094+time.tol) | 
#         (temp2$Mean.Duration > 9.300024-time.tol & temp2$Mean.Duration < 9.300024+time.tol), ] %>% 

temp2 <- temp2 %>% dplyr::filter(Trace %in% c("170711e", "170817b")) %>% dplyr::select(-IN.4)




temp2 <- temp2 %>% 
  group_by(Trace) %>% 
  mutate(IN.9 = IN.9 - min(IN.9, na.rm = T)) %>%
  # mutate(mV2 = mV - max(mV, na.rm = T)) %>% 
  mutate(ShiftSec = max(Time, na.rm = T)/denomerator) %>% 
  mutate(Time2 = ifelse(Time < max(Time, na.rm = T)-ShiftSec, Time+ShiftSec, Time-(max(Time, na.rm = T)-ShiftSec)) )

# temp2[temp2$Trace == "170817b", "mV2"] <- temp2[temp2$Trace == "170817b", "mV2"] + min(temp2[temp2$Trace == "170711e", "mV2"], na.rm = T)
# temp2[temp2$Trace == "170817b", "mV"] <- temp2[temp2$Trace == "170817b", "mV2"] + min(temp2[temp2$Trace == "170711e", "mV2"], na.rm = T)


X.shift <- (1.57 -0.355)

ggplot(temp2)+
  geom_line(data = temp2[temp2$Trace == "170711e",], aes(x = Time + X.shift, y = IN.9, group = Trace))+
  geom_line(data = temp2[temp2$Trace == "170711e",], aes(x = Time2 + X.shift, y = IN.9-10, group = Trace))+
  geom_line(data = temp2[temp2$Trace == "170817b",], aes(x = Time, y = IN.9-20, group = Trace))+
  geom_line(data = temp2[temp2$Trace == "170817b",], aes(x = Time2, y = IN.9-30, group = Trace))+
  geom_segment(aes(x = 0, xend = 1, y = -30, yend = -30), size = 1)+
  geom_segment(aes(x = 0, xend = 0, y = -30, yend = -25), size = 1)+
    # geom_vline(xintercept = 1.56)+
  geom_segment(aes(x = 1.56, xend = 1.56+0.2025056, y = 10, yend = 10), size = 1, color = "cornflowerblue")+
  geom_segment(aes(x = 1.56, xend = 1.56+0.3687559 , y = -10, yend = -10), size = 1, color = "cornflowerblue")+
  theme_void()
  
ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v1.pdf"))), 
       width = 8.79, height = 7.21)

ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v1.svg"))), 
       width = 8.79, height = 7.21)
}
```


Second test
```{r}
# Use fraction shift


temp3 <- left_join(mutate(plt.trace.variation, Trace = unlist(transpose(str_split(plt.trace.variation$Trace, "_"))[[1]]) ) , temp)

	
#   Trace mtime
# 1	170623b	2.799864
# 2	170803b	3.165165
# 3	170825a	3.200130
# 4	170925A	3.200130
# 5	170705a	3.240090
# 6	170710	3.240090
# 7	170711e	3.240090
# 8	170814b	4.300029
# 9	170808a	4.399929
# 10	170808b	4.399929
# 11	170811	4.399929
# 12	171016	4.399929
# 13	171017	4.399929
# 14	171201	4.399929
# 15	180717a	5.000000
# 16	170828a	5.200128
# 17	180717	5.200128
# 18	170728a	5.435892
# 19	170801a	5.435892
# 20	170802a	5.435892
# 21	170803a	5.435892
# 22	180718	5.660000
# 23	180718a	5.660000
# 24	170817b	5.900094
# 25	170713b	6.216777
# 26	170824a	9.300024

temp3 <- temp3 %>% dplyr::filter(Trace %in% c("170711e", "170814b", "180718a", "170817b")) %>% dplyr::select(-IN.4)

temp3$Trace <- factor(temp3$Trace, level = c("170711e", "170814b", "180718a", "170817b"))


# denomerator <- 16

for (denomerator in c(16, 8, 4, 2)){

temp3 <- temp3 %>% 
  group_by(Trace) %>% 
  mutate(IN.9 = IN.9 - min(IN.9, na.rm = T)) %>%
  # mutate(mV2 = mV - max(mV, na.rm = T)) %>% 
  mutate(ShiftSec = max(Time, na.rm = T)/denomerator) %>% 
  mutate(Time2 = ifelse(Time < max(Time, na.rm = T)-ShiftSec, Time+ShiftSec, Time-(max(Time, na.rm = T)-ShiftSec)) ) %>% 
  ungroup() %>% 
  mutate(shift_down = max(IN.9, na.rm = T)) %>% 
  mutate(numeric_fac = as.numeric(as.factor(Trace))) %>% 
  mutate(mV = IN.9 - (((numeric_fac-1) * 2) * shift_down) - shift_down ) %>% 
  mutate(mV2 = IN.9 - ((numeric_fac-1) * 2) * shift_down)

  
annotation_df <- temp3 %>% 
  group_by(Trace, ShiftSec, numeric_fac) %>% 
  summarise(#mV_max = max(mV, na.rm = T), 
            mV_min = min(mV, na.rm = T)#,
            # mV2_max = max(mV2, na.rm = T)#, 
            #mV2_min = min(mV2, na.rm = T)
            ) %>% 
  ungroup() %>% 
  mutate(ShiftSec = round(ShiftSec, digits = 3))


tic <- Sys.time()
temp3 %>% 
  ggplot()+
  geom_segment(data = annotation_df, aes(x = 0, xend = ShiftSec, y = mV_min, yend = mV_min), color = "cornflowerblue", size = 2)+
  geom_line(aes(x = Time, y = mV2, group = Trace))+
  geom_line(aes(x = Time2, y = mV, group = Trace))+
  geom_text(data = annotation_df, 
            aes(x = 0.12, y = mV_min+2, label = ShiftSec, group = Trace), 
            parse = T )+
  geom_path(data = data.frame(x = c(-0.1, -0.1, 0.9), y = c(-72, -82, -82)), aes(x = x, y = y))+
  # annotate("text", x = 0.12, y = 11, parse = TRUE, label = as.character(expression(paste(phi, 
  #                                                                                        " = "
  #                                                                                        )
  #                                                                                  )
  #                                                                       )
  #          )+
  theme_void()

ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v2.pdf"))), 
       width = 8.79, height = 7.21)

ggsave(here("data", "figures", as.character(paste0("individual_pro_", as.character(round(360/denomerator, digits = 2)), "_v2.svg"))), 
       width = 8.79, height = 7.21)
}
```


PCA is now shelved.
```{r}

# temp <- Orig[, c(
#   "Time",
#   "r11", "r12", "r1", "rc", "cc", "rmp", 
#   # "gj", 
#   # "intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk", "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a", "a.peak.nA", "htk.peak.nA", 
#   # "inter", "Trace", 
#   "Mean.Min.V", "Mean.Max.V", "Mean.Med.V", "Mean.Mean.V", "Mean.Duration", "Mean.On.Duration", "Mean.Duty.Cycle", "Onset.Delay", "P.Onset.Delay", "Mean.AUC", "Min.AUC", "Mean.AUC.mV.S", "Min.AUC.mV.S", "Cor"
# )] %>% 
#   dplyr::filter(Time == 40) %>% 
#   dplyr::select(-Time)
# 
# library(factoextra)
# z <- prcomp(~., data = temp, center = TRUE, scale. = TRUE)
# fviz_screeplot(z, addlabels = TRUE, ylim = c(0, 50))
# fviz_pca_var(z, col.var="contrib",
#              gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#              repel = TRUE # Avoid text overlapping
#              )
# 
# 
# ## Standardized protocols
# plt.list <- map(list(
#   c("PS.0.High.Amp", "PS.22.High.Amp", "PS.90.HA"),
#   c("PS.22", "PS.45", "PS.0", "PS.90"),
#   c("PS.0.High.Amp", "PS.22.High.Amp", "PS.90.HA", "PS.22", "PS.45", "PS.0", "PS.90")
# ), function(i){
#   temp <- Standard[Standard$Condition %in% i , c(
#     "Time",
#     "r11", "r12", "r1", "rc", "cc", "rmp", 
#     # "gj",
#     # "intercept.peak_htk", "slope.peak_htk", "intercept.end_htk", "slope.end_htk", "intercept.peak_a", "slope.peak_a", "intercept.end_a", "slope.end_a", "a.peak.nA", "htk.peak.nA",
#     # "inter", "Trace", 
#     "Mean.Min.V", "Mean.Max.V", "Mean.Med.V", "Mean.Mean.V", #"Mean.Duration", 
#          "Mean.On.Duration", "Mean.Duty.Cycle", "Onset.Delay", "P.Onset.Delay", "Mean.AUC", "Min.AUC", "Mean.AUC.mV.S", "Min.AUC.mV.S", "Cor"
#   )] %>% 
#     dplyr::filter(Time == 40) %>% 
#     dplyr::select(-Time)
#   
#   z <- prcomp(~., data = temp, center = TRUE, scale. = TRUE)
#   plt.scree <- fviz_screeplot(z, addlabels = TRUE#, ylim = c(0, 50)
#                               )
#   plt.biplt <- fviz_pca_var(z, col.var="contrib",
#                             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#                             repel = TRUE # Avoid text overlapping
#   )
#   
#   return(list(scree = plt.scree,
#               biplt = plt.biplt))
# })
# 
# 
# plt.list[[1]]$scree
# plt.list[[1]]$biplt
# plt.list[[2]]$scree
# plt.list[[2]]$biplt
# plt.list[[3]]$scree
# plt.list[[3]]$biplt
```



model comparison with "PS.22.orig"  "PS.0.orig"   "PS.180.orig" "PS.90.orig"  "PS.45.orig" 
```{r}
# Make up a new data set so we can use the random formula we used above for nlme::lme 
original.obs.clean <-M.clean[M.clean$Condition %in% unique(Orig$Condition), 
                             c("Condition", "Experiment", "Time", "Inj_Cell", "inter", "rc")] %>% 
  group_by(Condition, Experiment, Time) %>% 
  dplyr::summarise(
    # Condition = Condition, 
    # Experiment = Experiment, 
    # Time = Time, 
    rc = mean(rc, na.rm = T)) %>% 
  dplyr::ungroup()


df <- full_join(original.obs.clean, one.trace.orig, by = "Experiment")

df <- df[!is.na(df$rc), ]




library(AICcmodavg)


df$Condition_Continuous <- NA
df[df$Condition == "PS.0.orig", "Condition_Continuous"] <- 0.0
df[df$Condition == "PS.22.orig", "Condition_Continuous"] <- 0.625
df[df$Condition == "PS.45.orig", "Condition_Continuous"] <- 0.125
df[df$Condition == "PS.90.orig", "Condition_Continuous"] <- 0.25
df[df$Condition == "PS.180.orig", "Condition_Continuous"] <- 0.5




mods <- list(
    nlme::lme(rc ~ Condition*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Condition_Continuous*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.Min.V*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.Max.V*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.Med.V*Time, random = ~1 | Experiment, method = "ML", data = df),
    
    nlme::lme(rc ~ Mean.Mean.V*Time, random = ~1 | Experiment, method = "ML", data = df),
        #nlme::lme(rc ~ Mean.Duration*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.On.Duration*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.Duty.Cycle*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Onset.Delay*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ P.Onset.Delay*Time, random = ~1 | Experiment, method = "ML", data = df),
    
    nlme::lme(rc ~ Mean.AUC*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Min.AUC*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.AUC.mV.S*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Min.AUC.mV.S*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Cor*Time, random = ~1 | Experiment, method = "ML", data = df)
  )

mod.compare.orig <- aictab(
  cand.set = mods
)

mod.compare.orig



# df$Condition <- as.factor(df$Condition)
# anova(mod <- lme(rc ~ Condition*Time, random=~1|Experiment, data=df, method="ML",na.action=na.omit))
# glht(mod, linfct=mcp(Condition="Tukey"))
# 
# glht(anova.lme(mods[[11]]), linfct=mcp(Mean.AUC="Tukey"))


# anova(mods[[11]],
#       mods[[4]],
#       mods[[1]])

```

figure to answer djs question about the interacton of stimulus protocol and phase
```{r}
# hard code the protocols that correspond to each trace as a col.
Stim_Trace_Pairs <- tibble::tribble(
     ~Trace, ~Duration,  ~StimId,
  "170623b",  2.799864,      "a",
  "170803b",  3.165165,      "b",
  "170825a",   3.20013,      "c",
  "170925A",   3.20013,      "c",
  "170705a",   3.24009,      "d",
   "170710",   3.24009,      "d",
  "170711e",   3.24009,      "e",
  "170814b",  4.300029,      "f",
  "170808a",  4.399929,      "g",
  "170808b",  4.399929,      "g",
   "170811",  4.399929,      "g",
   "171016",  4.399929,      "h",
   "171017",  4.399929,      "i",
   "171201",  4.399929, "hprime",
  "180717a",         5,      "j",
  "170828a",  5.200128,      "k",
   "180717",  5.200128,      "k",
  "170728a",  5.435892,      "l",
  "170801a",  5.435892,      "l",
  "170802a",  5.435892,      "l",
  "170803a",  5.435892,      "l",
   "180718",      5.66,      "m",
  "180718a",      5.66,      "m",
  "170817b",  5.900094,      "n",
  "170713b",  6.216777,      "o",
  "170824a",  9.300024,      "p"
  )
Stim_Trace_Pairs <- Stim_Trace_Pairs %>% dplyr::select(-Duration)

djs.temp <- df %>% 
  dplyr::select(Experiment, Trace, Condition, Time, rc) %>% 
  pivot_wider(names_from = Time, values_from = rc) %>%
  mutate(`20` = `20`-`0`) %>%
  mutate(`40` = `40`-`0`) %>%
  mutate(`60` = `60`-`0`) %>%
  mutate(`0` = `0`-`0`) %>%
  # group_by(Experiment) %>%
  pivot_longer(cols = c(`0`, `20`, `40`, `60`), names_to = "Time", values_to = "rc") %>% 
  mutate(Change = ifelse(rc >= 0 , 1, -1))

# add in stim ids.
djs.temp <- full_join(rename(Stim_Trace_Pairs, Experiment = Trace), djs.temp)


#Create a data frame with the faceting variables
tp <- djs.temp %>% dplyr::select(Condition, Trace, Time, Change, StimId) %>% filter(Time == 60) %>% distinct()

# by experiment/trace
ggplot(djs.temp)+
  geom_rect(data = tp, aes(fill = as.factor(Change)),xmin = -Inf,xmax = Inf, ymin = -Inf,ymax = Inf,alpha = 0.3) +
  geom_hline(yintercept = 0, color = "cornflowerblue")+
  # geom_point(data = djs.temp[djs.temp$Time == 40, ], aes(color = Change))+
  geom_pointline(aes(x = Time, y = rc, group = Experiment), shape = 1, color = "black")+
  ylim(-2, 3.5)+
  facet_grid(Condition~Trace)+
  # facet_grid(Trace~Condition)+
  scale_fill_manual(values = c("Red", "Green"))+
  theme_base()+
  theme(legend.position = "")

# by stim id
tp2 <- tp %>% group_by(Condition, StimId) %>% mutate(Change = mean(Change)) %>% distinct() %>% ungroup()

ggplot(djs.temp)+
  geom_rect(data = tp2, aes(fill = Change),xmin = -Inf,xmax = Inf, ymin = -Inf,ymax = Inf,alpha = 0.3) +
  geom_hline(yintercept = 0, color = "cornflowerblue")+
  geom_pointline(aes(x = Time, y = rc, group = Experiment), shape = 1, color = "black")+
  ylim(-2, 3.5)+
  facet_grid(Condition~StimId)+
  # facet_grid(Trace~Condition)+
  # scale_fill_manual(values = c("Red", "Green"))+
  scale_fill_gradientn(colors = c("Red", "Grey", "Green"))+
  theme_base()+
  theme(legend.position = "")



ggplot(djs.temp)+
  # geom_rect(data = tp, aes(fill = Change),xmin = -Inf,xmax = Inf, ymin = -Inf,ymax = Inf,alpha = 0.3) +
  geom_hline(yintercept = 0, color = "cornflowerblue")+
  # geom_point(data = djs.temp[djs.temp$Time == 40, ], aes(color = Change))+
  geom_pointline(aes(x = Time, y = rc, group = Experiment), shape = 1, color = "black")+
  ylim(-2, 3.5)+
  facet_grid(.~Condition)+
  scale_color_manual(values = c("Red", "Green"))+
  theme_base()+
  theme(legend.position = "")







```



Model comparison with  "PS.90.HA", "PS.22", "PS.45", "PS.0", "PS.90"
```{r}
# Make up a new data set so we can use the random formula we used above for nlme::lme 
low.obs.clean <- M.clean[M.clean$Condition %in% c("PS.22", "PS.45", "PS.0", "PS.90"), 
                             c("Condition", "Experiment", "Time", "Inj_Cell", "inter", "rc")] %>% 
  group_by(Condition, Experiment, Time) %>% 
  dplyr::summarise(
    # Condition = Condition, 
    # Experiment = Experiment, 
    # Time = Time, 
    rc = mean(rc, na.rm = T)) %>% 
  dplyr::ungroup()


df <- full_join(low.obs.clean, rename(one.trace.standard, Stim.Source = Experiment), by = "Condition")

df <- df[!is.na(df$rc), ]

# Add continuous version
df$Condition_Continuous <- NA
df[df$Condition == "PS.0", "Condition_Continuous"] <- 0.0
df[df$Condition == "PS.22", "Condition_Continuous"] <- 0.625
df[df$Condition == "PS.45", "Condition_Continuous"] <- 0.125
df[df$Condition == "PS.90", "Condition_Continuous"] <- 0.25


mods.standard <- list(
    nlme::lme(rc ~ Condition*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Condition_Continuous*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.Min.V*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.Max.V*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.Med.V*Time, random = ~1 | Experiment, method = "ML", data = df),
    
    nlme::lme(rc ~ Mean.Mean.V*Time, random = ~1 | Experiment, method = "ML", data = df),
      # nlme::lme(rc ~ Mean.Duration*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.On.Duration*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.Duty.Cycle*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Onset.Delay*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ P.Onset.Delay*Time, random = ~1 | Experiment, method = "ML", data = df),
    
    nlme::lme(rc ~ Mean.AUC*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Min.AUC*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Mean.AUC.mV.S*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Min.AUC.mV.S*Time, random = ~1 | Experiment, method = "ML", data = df),
    nlme::lme(rc ~ Cor*Time, random = ~1 | Experiment, method = "ML", data = df)
  )

mod.compare.standard <- aictab(
  cand.set = mods.standard
)
```

contrast the two aic tables
```{r}
#TODO

mod.compare.orig$data <- "original"
mod.compare.standard$data <- "standard"

M <- rbind(mod.compare.orig, mod.compare.standard)

M$Modnum <- as.numeric(stringr::str_remove(M$Modnames, "Mod"))

mod.predictors <- c("Condition",
  "Condition_Continuous",
  "Mean.Min.V",
  "Mean.Max.V",
  "Mean.Med.V",
  
  "Mean.Mean.V",
  # "Mean.Duration",
  "Mean.On.Duration",
  "Mean.Duty.Cycle",
  "Onset.Delay",
  "P.Onset.Delay",
  
  "Mean.AUC",
  "Min.AUC",
  "Mean.AUC.mV.S",
  "Min.AUC.mV.S",
  "Cor")

M$predictor <- NA

for (i in seq_along(mod.predictors)){
  M[M$Modnum == i, "predictor"] <- mod.predictors[i]
    
}
```


```{r}
# M %>% 
#   ggplot(aes(x = data, y = AICc, 
#              label = Modnames, group = Modnames,
#              color = data))+
#   geom_point()+
#   geom_line(color = "black")+
#   geom_text(data = M[M$data == "standard",], check_overlap = TRUE, position = "dodge")+
#   geom_text(data = M[M$data == "original",], check_overlap = TRUE, position = "dodge")
  

M %>% 
  ggplot(aes(x = data, y = Delta_AICc, 
             label = predictor, group = Modnames,
             color = data))+
  # geom_point()+
  geom_line(color = "black")+
  geom_text(data = M[M$data == "standard",], check_overlap = TRUE, position = "dodge")+
  geom_text(data = M[M$data == "original",], check_overlap = TRUE, position = "dodge")
  
  mutate(Modnames = as.numeric(stringr::str_remove(Modnames, "Mod"))) %>% 
  ggplot(aes(x = Modnames, y = Delta_AICc, color = data, group = data))+
  geom_line()+
  geom_point()
```


```{r}
as_tibble(M[M$data == "original", c("predictor", "K", "AICc", "Delta_AICc", "ModelLik", "AICcWt", "LL", "Cum.Wt")])
as_tibble(M[M$data == "standard", c("predictor", "K", "AICc", "Delta_AICc", "ModelLik", "AICcWt", "LL", "Cum.Wt")])

M %>% 
  ggplot(aes(x = predictor, y = Delta_AICc, 
             label = predictor, group = data,
             color = data))+
  geom_segment(aes(xend = predictor, yend = 0))+
  geom_point()+
    # geom_line(color = "black")+
  coord_flip()+
  facet_grid(.~data)

```

```{r}
M.o <- as_tibble(M[M$data == "original", c("predictor", "K", "AICc", "Delta_AICc", "ModelLik", "AICcWt", "LL", "Cum.Wt")])

M.o[M.o$predictor == "Condition_Continuous", "predictor"] <- "Phase"
M.o[M.o$predictor == "Mean.AUC", "predictor"] <- "Area Under Curve" 
M.o[M.o$predictor == "Mean.Med.V", "predictor"] <- "Median mV" 
M.o[M.o$predictor == "Condition", "predictor"] <- "Phase (Discrete)" 
M.o[M.o$predictor == "Mean.Mean.V", "predictor"] <- "Mean mV" 
M.o[M.o$predictor == "Mean.Min.V", "predictor"] <- "Minimum mV" 
M.o[M.o$predictor == "P.Onset.Delay", "predictor"] <- "Percent Delay" 
M.o[M.o$predictor == "Min.AUC.mV.S", "predictor"] <- "Normalized Joint AUC" 
M.o[M.o$predictor == "Cor", "predictor"] <- "Stimulus Correlation" 
M.o[M.o$predictor == "Onset.Delay", "predictor"] <- "Delay" 
M.o[M.o$predictor == "Min.AUC", "predictor"] <- "Overlapping AUC" 
M.o[M.o$predictor == "Mean.AUC.mV.S", "predictor"] <- "Normalized AUC" 
M.o[M.o$predictor == "Mean.Max.V", "predictor"] <- "Max mV" 
M.o[M.o$predictor == "Mean.On.Duration", "predictor"] <- "On Duration" 
M.o[M.o$predictor == "Mean.Duty.Cycle", "predictor"] <- "Duty Cycle"


# order low dAICc to high
correct.order <- M.o %>% arrange(Delta_AICc) %>% dplyr::select(predictor)

M.o$predictor <- factor(M.o$predictor, levels = unlist(correct.order) )


library(ggrepel)




### Params ####
text.size = 20
  
plt.nv.aicc <-M.o %>% 
  mutate(rDelta_AICc = as.character(round(Delta_AICc, digits = 1))) %>% 
  ggplot(aes(x = predictor, y = Delta_AICc, 
             label = rDelta_AICc
  ))+
  geom_segment(aes(xend = predictor, yend = 0))+
  geom_point()+
  
  ggrepel::geom_text_repel(direction = "y", nudge_y = 0.2, color = "darkgray")+
  
  geom_segment(aes(x    = 1,
                   y    = 2,
                   xend = 1,
                   yend = 0.5), 
               arrow = arrow(length = unit(0.015, "npc"),
                             type = "closed"),
               color = "red")+
  geom_text(aes(x = 1, y = 2.5,
                 label = "🟉"), color = "red")+
  
  
  labs(x = "", y = expression(paste("Relative Model Error "," (", Delta, "AICc", ")")) )+
  theme(axis.text.x = element_text(angle=45,hjust=1))+
  theme(
    # axis.text = element_text(size = rel(2), angle = 0),
        text = element_text(size=text.size)
        )
```





# Fig 1 traces
```{r}

# 180223_0009.abf
# 
# Use 55-115 Sec
# For Inset, 
# Use 55-64


library(readABF)
# Really just a wrapper for loadABF()
readABF_as_matrix <- function(
  path = "",
  channels = c("IN 4", "IN 9")){

  trace <- readABF::readABF(file = path)

  start.time <- trace$header$recTime[1]
  end.time <- trace$header$recTime[2]
  obs <- nrow(trace$data[[1]])

  temp <- trace$data[[1]][, (trace$channelNames %in% channels)]
  temp <- as.matrix(temp)

  colnames(temp) <- trace$channelNames[trace$channelNames %in% channels]
  temp <- cbind(temp, Time = seq(from = start.time,
                                 to = end.time,
                                 length.out = obs))

  return(temp)
}


# temp <- readABF::readABF(here("inst", "extdata", "all_5", "180223_0009.abf"))

temp <- readABF_as_matrix(path = here("inst", "extdata", "all_5", "180223_0009.abf"),
                          channels = c("IN 4", "IN 6", "IN 9", "IN 11", "IN 2", "IN 14"))

temp <- janitor::clean_names(dat = as.data.frame(temp), 'upper_camel')
temp <- as_tibble(temp)
temp <- temp %>% mutate(Seconds = Time - min(Time, na.rm = T))
# Select target time, 55-64 seconds in.
temp <- dplyr::filter(temp, Seconds > 55 & Seconds < 64)

# temp <- temp[seq(1, nrow(temp), by = 10), ]

temp2 <- temp

# Test out k params ----

smooth.k <- 7

plt.list <- 
map(ceiling(seq(2, 27, length.out = 5)), function(smooth.k){
  temp <- temp2
  
  
  temp$In2 <- rollmean(temp$In2, k = smooth.k, fill = NA)
  temp$In4 <- rollmean(temp$In4, k = smooth.k, fill = NA)
  temp$In6 <- rollmean(temp$In6, k = smooth.k, fill = NA)
  temp$In9 <- rollmean(temp$In9, k = smooth.k, fill = NA)
  temp$In11 <- rollmean(temp$In11, k = smooth.k, fill = NA)
  temp$In14 <- rollmean(temp$In14, k = smooth.k, fill = NA)
  
  
  
  scale.bar.df <- as.data.frame(
    expand.grid(Ch = c("LC1", "LC2", "LC3", "LC4", "LC5"), 
                Seconds = c(0,0),
                mV = c(0,3)))
  
  scale.bar.df <- rbind(scale.bar.df, data.frame(Ch = "LC1", Seconds = 1, mV = 3))
  
  plt <- temp %>%
    gather(c("In2",  "In4",  "In6",  "In9",  "In11", "In14"), key = "Ch", value = "mV") %>%
    mutate(Ch = ifelse(Ch == "In2", "LC4", 
                       ifelse(Ch == "In4", "LC5", 
                              ifelse(Ch == "In6", "LC3", 
                                     ifelse(Ch == "In9", "LC2", 
                                            ifelse(Ch == "In11", "LC1", 
                                                   ifelse(Ch == "In14", "Trunk", "NA")
                                            )
                                     )
                              )
                       )
    )
    ) %>% 
    group_by(Ch) %>% 
    mutate(mV = mV - min(mV, na.rm = T)) %>% 
    ungroup() %>% 
    mutate(Seconds = Seconds - min(Seconds, na.rm = T)) %>% 
    ggplot(aes(Seconds, mV, color = Ch))+
    # geom_path(data = scale.bar.df, color = "black", size = 2)+
    geom_path()+
    # facet_wrap(Ch~., ncol = 1)+
    facet_wrap(Ch~., ncol = 1, scales = "free")+
    theme_void()+
    theme(legend.position = "")+
    # scale_color_manual(values = c(RColorBrewer::brewer.pal(7, "Reds")[3:7], "Black")) # Nice analogous scheme
    scale_color_manual(values = c(rep(RColorBrewer::brewer.pal(7, "Reds")[7], times = 5), "Black")) # save color for easy comparison on k
  
  return(plt)
  
})

cowplot::plot_grid(plotlist = plt.list, nrow = 1)


# Test out SNR based K selection ----
plt.list <- 
map(c(1, 5, 10, 100, 1000),
  # ceiling(seq(1, 50, length.out = 5)), 
  function(smooth.k){
  temp <- temp2
  
  # We want a higher K based on the range which we'll uses as a proxy for SNR
  # If the relative range is high then we want a low K, so we set a high k and scale it down with ceiling(k/ XminRange)
  k.scaling.factors <- temp %>% 
    gather(c("In2",  "In4",  "In6",  "In9",  "In11", "In14"), key = "Ch", value = "mV") %>%
    group_by(Ch) %>% 
    dplyr::summarize(range = abs(max(mV) - min(mV)) ) %>% 
    mutate(range = range/min(range))
  
  temp$In2 <-  zoo::rollmean(temp$In2,  k = as.numeric(ceiling(smooth.k/ k.scaling.factors[k.scaling.factors$Ch == "In2", "range"])), fill = NA)
  temp$In4 <-  zoo::rollmean(temp$In4,  k = as.numeric(ceiling(smooth.k/ k.scaling.factors[k.scaling.factors$Ch == "In4", "range"])), fill = NA)
  temp$In6 <-  zoo::rollmean(temp$In6,  k = as.numeric(ceiling(smooth.k/ k.scaling.factors[k.scaling.factors$Ch == "In6", "range"])), fill = NA)
  temp$In9 <-  zoo::rollmean(temp$In9,  k = as.numeric(ceiling(smooth.k/ k.scaling.factors[k.scaling.factors$Ch == "In9", "range"])), fill = NA)
  temp$In11 <- zoo::rollmean(temp$In11, k = as.numeric(ceiling(smooth.k/ k.scaling.factors[k.scaling.factors$Ch == "In11", "range"])), fill = NA)
  temp$In14 <- zoo::rollmean(temp$In14, k = as.numeric(ceiling(smooth.k/ k.scaling.factors[k.scaling.factors$Ch == "In14", "range"])), fill = NA)
  
  scale.bar.df <- as.data.frame(
    expand.grid(Ch = c("LC1", "LC2", "LC3", "LC4", "LC5"), 
                Seconds = c(0,0),
                mV = c(0,3)))
  
  scale.bar.df <- rbind(scale.bar.df, data.frame(Ch = "LC1", Seconds = 1, mV = 3))
  
  plt <- temp %>%
    gather(c("In2",  "In4",  "In6",  "In9",  "In11", "In14"), key = "Ch", value = "mV") %>%
    mutate(Ch = ifelse(Ch == "In2", "LC4", 
                       ifelse(Ch == "In4", "LC5", 
                              ifelse(Ch == "In6", "LC3", 
                                     ifelse(Ch == "In9", "LC2", 
                                            ifelse(Ch == "In11", "LC1", 
                                                   ifelse(Ch == "In14", "Trunk", "NA")
                                            )
                                     )
                              )
                       )
    )
    ) %>% 
    group_by(Ch) %>% 
    mutate(mV = mV - min(mV, na.rm = T)) %>% 
    ungroup() %>% 
    mutate(Seconds = Seconds - min(Seconds, na.rm = T)) %>% 
    ggplot(aes(Seconds, mV, color = Ch))+
    # geom_path(data = scale.bar.df, color = "black", size = 2)+
    geom_path()+
    # facet_wrap(Ch~., ncol = 1)+
    facet_wrap(Ch~., ncol = 1, scales = "free")+
    theme_void()+
    theme(legend.position = "")+
    # scale_color_manual(values = c(RColorBrewer::brewer.pal(7, "Reds")[3:7], "Black")) # Nice analogous scheme
    scale_color_manual(values = c(rep(RColorBrewer::brewer.pal(7, "Reds")[7], times = 5), "Black")) # save color for easy comparison on k
  
  return(plt)
  
})

cowplot::plot_grid(plotlist = plt.list, nrow = 1, labels = c("1", "5", "10", "100", "1000"))#labels = LETTERS)
```



# Write out figures
```{r}
# 
# 
# fig1.part
# ggsave(here("data", "figures", "fig1.part.png"), plot = last_plot(), width = 5, height = 5, units = "in")
# 
# plt.tea.hv.a
# ggsave(here("data", "figures", "fig2.png"), plot = last_plot(), width = 7.14, height = 5.81, units = "in")
# 
# 
# plt.lv.a
# ggsave(here("data", "figures", "fig3.png"), plot = last_plot(), width = 7.14, height = 5.81, units = "in")
# 
# 
# plt.nv.a+labs(subtitle = expression(paste("Varied Waveforms Produce Inconsistent Effects of Phase on ", Delta, "Rc"))) + plt.nv.aicc+labs(subtitle = expression(paste("Efficacy of Predictors to Explain  ", Delta, "Rc"))) + plot_layout(widths = c(3, 2), ) + plot_annotation(tag_levels = 'A')
# 
# ggsave(here("data", "figures", "fig4.png"), plot = last_plot(), width = 10.68, height = 5.81, units = "in")



fig1.part
ggsave(here("data", "figures", "fig1.part.pdf"), plot = last_plot(), width = 5, height = 5, units = "in")
ggsave(here("data", "figures", "fig1.part.svg"), plot = last_plot(), width = 5, height = 5, units = "in")

plt.tea.hv.a
ggsave(here("data", "figures", "fig2.pdf"), plot = last_plot(), width = 7.14, height = 5.81, units = "in")
ggsave(here("data", "figures", "fig2.svg"), plot = last_plot(), width = 7.14, height = 5.81, units = "in")

plt.lv.a
ggsave(here("data", "figures", "fig3.pdf"), plot = last_plot(), width = 7.14, height = 5.81, units = "in")
ggsave(here("data", "figures", "fig3.svg"), plot = last_plot(), width = 7.14, height = 5.81, units = "in")

plt.nv.a+labs(subtitle = expression(paste("Varied Waveforms Produce Inconsistent Effects of Phase on ", Delta, "Rc"))) + plt.nv.aicc+labs(subtitle = expression(paste("Efficacy of Predictors to Explain  ", Delta, "Rc"))) + plot_layout(widths = c(3, 2)) + plot_annotation(tag_levels = 'A')
ggsave(here("data", "figures", "fig4.pdf"), plot = last_plot(), width = 10.68, height = 5.81, units = "in")
ggsave(here("data", "figures", "fig4.svg"), plot = last_plot(), width = 10.68, height = 5.81, units = "in")

library(cowplot)
cowplot::plot_grid(plotlist = list(
plt.nv.a+labs(subtitle = expression(paste("Varied Waveforms Produce Inconsistent Effects of Phase on ", Delta, "Rc"))),
plt.nv.aicc+labs(subtitle = expression(paste("Efficacy of Predictors to Explain  ", Delta, "Rc")))  
))
ggsave(here("data", "figures", "fig4'.pdf"), plot = last_plot(), width = 10.68, height = 5.81, units = "in")
ggsave(here("data", "figures", "fig4'.svg"), plot = last_plot(), width = 10.68, height = 5.81, units = "in")

```







```{r}
# library(nlme)
# library(multcomp)
# 
# anova(mod <- lme(Yield~Crop, random=~1|ID, data=DFField, method="ML",na.action=na.omit))
# 
# glht(mod, linfct=mcp(Crop="Tukey"))
```















saveRDS(me_all, file = paste0(getwd(), "/data/chapter2/", "resampled_2x2_model_results", ".rds"))
knitr::kable(out)


# Shelved analysis that we can return to if need be.


## what if we collapse down to pre/post?

```{r eval=FALSE, include=FALSE}


M.clean_prepost <- M.clean
  
M.clean_prepost[M.clean_prepost$Time %in% c(20, 40, 60), "Time"] <- 20


M.clean_prepost <- M.clean_prepost %>%
  group_by(Condition, Experiment, Inj_Cell, Time) %>% 
  summarise(r11 = mean(r11, na.rm = T),
            r12 = mean(r12, na.rm = T),
            r1 = mean(r1, na.rm = T),
            rc = mean(rc, na.rm = T),
            cc = mean(cc, na.rm = T),
            rmp = mean(rmp, na.rm = T),
            gj = mean(gj, na.rm = T),
            intercept.peak_htk = mean(intercept.peak_htk, na.rm = T),
            slope.peak_htk = mean(slope.peak_htk, na.rm = T),
            intercept.end_htk = mean(intercept.end_htk, na.rm = T),
            slope.end_htk = mean(slope.end_htk, na.rm = T),
            intercept.peak_a = mean(intercept.peak_a, na.rm = T),
            slope.peak_a = mean(slope.peak_a, na.rm = T),
            intercept.end_a = mean(intercept.end_a, na.rm = T),
            slope.end_a = mean(slope.end_a, na.rm = T),
            a.peak.nA = mean(a.peak.nA, na.rm = T),
            htk.peak.nA = mean(htk.peak.nA, na.rm = T)
  ) %>% ungroup()


## Make counterfactual dfs and run tests ====
if (make.resample.results){
  set.seed(657984118)
  
## split all.tests up into a list of dfs ====
all.tests.list <- map(1:nrow(all.tests), function(i){
  all.tests[i, ]
})

## pull out the relevant data to shuffle ====
prepped.df <- furrr::future_map(seq_along(all.tests.list), 
                                function(i, 
                                         in.data = M.clean_prepost){
                                  
                                  test.info <- all.tests.list[[i]]
                                  
                                  data.slice <- ready_data_to_test(
                                    input.df = in.data,
                                    dept.var = as.character(test.info[, "DV"]),
                                    vis.conditions = str_split(string = as.character(test.info[, "Groups"]), pattern = "_")[[1]], # Split up char string.
                                    use.times = c(0, 20), #FIXME
                                    use.pseudorep.diff.tol = T,
                                    use.diff.tol = 0.5,
                                    obs.is.network = as.logical(test.info[, "Obs.Net"]))
                                  
                                  
                                })



## Make up all the datasets to be used ====
# The first one is the actual data
df_and_counterfactual <- furrr::future_map(prepped.df, 
                                           function(inputdf, 
                                                    iterations = resample.nreps
                                           ){
                                             furrr::future_map(seq(1, iterations), function(
                                               i
                                             ){
                                               if (i == 1) {
                                                 return(inputdf)
                                               } else {
                                                 mutate(inputdf,
                                                        dept.var = sample(unlist(dplyr::select_at(inputdf, "dept.var")),
                                                                          replace = T
                                                        )
                                                 )
                                               }
                                             })
                                           })

## Apply the proscribed stats test ====
nested_test_results <- furrr::future_map(seq_along(df_and_counterfactual), 
                                         function(i){
                                           
                                           df.list <- df_and_counterfactual[[i]]
                                           
                                           df.main.formula <- as.formula(all.tests[i, "Model"])
                                           df.rand.formula <- as.formula(all.tests[i, "Random"])
                                           
                                           furrr::future_map(df.list, function(df, main.formula = df.main.formula, rand.formula = df.rand.formula){
                                             
                                             # get rid of NA in DV ----
                                             input.df <- df[!is.na(df$dept.var), ]
                                             
                                             # test ----
                                             # In some situations this will fail with  "Error in MEEM(object, conLin, control$niterEM) : \n  Singularity in backsolve at level 0, block 1\n"
                                             
                                             # the result of nlme will be a list unless there was an error in which case it will be a character type
                                             # if fm is a character type then we'll make a new random df on the fly UNLESS j = 1 in which case we'll provide an error message
                                             
                                             fm <- try(nlme::lme(
                                               main.formula,
                                               # dept.var ~ Time * Condition,
                                               random = rand.formula,
                                               # random = ~1 | Experiment,
                                               method = "REML",
                                               data = input.df
                                             ))
                                             
                                             # make up replacement value on the fly. ----
                                             if (typeof(fm) == "character") {
                                               if (j == 1) {
                                                 warning("\n\nThe input data produced an error. 
                \nIt could not be fit by nlme::lme() 
                \nConsider fitting it manually before trying again.")
                                               } else {
                                                 counter <- 1
                                                 while (counter > 100 & typeof(fm) == "character") {
                                                   input.df <- mutate(preped.df,
                                                                      dept.var = sample(unlist(dplyr::select_at(preped.df, "dept.var")),
                                                                                        replace = T
                                                                      )
                                                   )
                                                   
                                                   fm <- try(nlme::lme(
                                                     as.formula(all.tests[i, "Model"]),
                                                     # dept.var ~ Time * Condition,
                                                     random = as.formula(all.tests[i, "Random"]),
                                                     # random = ~1 | Experiment,
                                                     method = "REML",
                                                     data = input.df
                                                   ))
                                                 }
                                               }
                                               
                                             }
                                             
                                             return(fm)
                                           })
                                         }) 


## Make tables of asymptotic test statistics ====
asymptotic_res <- furrr::future_map(nested_test_results, function(test_set){
  anova.lme(test_set[[1]])
})

## Make tables of empirical test statistics ====

### get all the f values in a single df for each test ####
resampled_distribution <- furrr::future_map(nested_test_results, function(test_set){
  # test_set <- nested_test_results[[1]]
  
  
  #Debugging. Error in solving produced an error here.
  # for (i in seq_along(nested_test_results)){
  #   for (j in 1:1000){
  #     
  #     i = 39
  #     j = 72
  #     
  #     fm <- nested_test_results[[i]][[j]]
  #     typeof(fm)
  #     
  #     out2 <- try(anova.lme(fm))[, "F-value"]
  #     
  #     print(paste(as.character(i), "|", as.character(j)))
  #     print(out2)
  #   }
  # }
  
  
  # join into dataframe (asymptotic == row 1)
  fvals <- furrr::future_map(test_set, function(fm){
    # if there was an error in solving, e.g. Singularity in backsolve at level 0, we want to drop this value.
    if (typeof(fm) == "character"){
      table <- NA
    } else {
      table <- try(anova.lme(fm))[, "F-value"]      
    }
    return(table)
  })
  
  fvals <- fvals %>% 
    reduce(rbind) %>% 
    as.data.frame()
  
  # if there were any errors there will be a blank in the dataframe. Drop it.
  fvals <- fvals[!is.na(fvals$V1), ]
  
  # apply appropriate labels
  names(fvals) <- anova.lme(test_set[[1]]) %>% rownames()
  
  return(fvals)
})

### convert into empirical p values ####
resampled_pvals <- furrr::future_map(resampled_distribution, function(resampled_f){
  pvals <- resampled_f[1, ]
  
  for (i in seq(1, ncol(pvals))){
    pvals[1, i] <- mean(resampled_f[1, i] <= resampled_f[, i])
    
  }
  
  return(pvals)
})

### Add resampled p values to asymptotic
asymp_resamp_stats <- furrr::future_map(seq_along(asymptotic_res), function(i){
  
  table <- asymptotic_res[[i]]
  resampled_p <- resampled_pvals[[i]]
    
  table$`ep-value` <- NA
  table$`ep-value` <- as.vector(t(resampled_p))
  
  return(table)
})

### Add annotations
asymp_resamp_stats_annotated <- furrr::future_map(seq_along(asymp_resamp_stats), function(i){
  
  temp <- asymp_resamp_stats[[i]]
  
  temp$parameter <- rownames(temp)
  temp$response <- all.tests[i, "DV"]
  temp$groups <- all.tests[i, "Groups"]
  
  # if it's class anova.lme then selection with new cols causes it to choke.
  temp <- as.data.frame(temp)
  # re order to make sorting easier
  temp <- temp[, c(7:8, 6,1:5)]
  
  return(temp)
  
})

### Make summary stats table 
all_stats <- do.call(rbind, asymp_resamp_stats_annotated)
}


### Make paramter estimates and summary table 
param_estimates <- map(seq_along(nested_test_results), function(i){
  fm <- nested_test_results[[i]][[1]]
  params <- tidy(fm)
  # params <- tidy(test.results[[i]]$res[[1]])
  params <- params %>% dplyr::select(term, estimate) %>% filter(term != "(Intercept)") %>% distinct() %>% rename(Term = term)
  params <- rbind(data.frame(Term = c("(Intercept)"), estimate = c(NA)),
                  params)
  
  params <- params %>% mutate(
    DV = all.tests[i, "DV"],
    Groups = all.tests[i, "Groups"])
  
  params <- params[, c("DV", "Groups", "Term", "estimate")]
})

all_param_estimates <- do.call(rbind, param_estimates)

## Cache all Resampling objects ====


## Write out tables ====
if (write.resample.results){
  write.csv(all_param_estimates, file = here("data", "stats_collapsed_df", "all_param_estimates.csv"))
  
  write.csv(all_stats, file = here("data", "stats_collapsed_df", "all_stats.csv"), row.names = F)
  
  walk(asymp_resamp_stats_annotated, function(df){
    
    file.name <- paste(
      as.character(df[1, "response"]), 
      "-",
      as.character(df[1, "groups"]),
      ".csv",
      sep = "")  
    
    write.csv(df, file = here("data", "stats_collapsed_df", file.name), row.names = F)
  })
  
  
}







    # write.csv(df, file = here("data", "stats_collapsed_df", file.name), row.names = F)
   
```

## what if there is no t=60
```{r eval=FALSE, include=FALSE}

# WARNING
# Close everything else before running this bit!
# Running required ~ 11GB ram for 1000 resamplings


## Make counterfactual dfs and run tests ====
if (make.resample.results){
  set.seed(657984118)
  
## split all.tests up into a list of dfs ====
all.tests.list <- map(1:nrow(all.tests), function(i){
  all.tests[i, ]
})

## pull out the relevant data to shuffle ====
prepped.df <- furrr::future_map(seq_along(all.tests.list), 
                                function(i, 
                                         in.data = M.clean){
                                  
                                  test.info <- all.tests.list[[i]]
                                  
                                  data.slice <- ready_data_to_test(
                                    input.df = in.data,
                                    dept.var = as.character(test.info[, "DV"]),
                                    vis.conditions = str_split(string = as.character(test.info[, "Groups"]), pattern = "_")[[1]], # Split up char string.
                                    use.times = c(0, 20, 40), #FIXME
                                    use.pseudorep.diff.tol = T,
                                    use.diff.tol = 0.5,
                                    obs.is.network = as.logical(test.info[, "Obs.Net"]))
                                  
                                  
                                })

## Make up all the datasets to be used ====
# The first one is the actual data
df_and_counterfactual <- furrr::future_map(prepped.df, 
                                           function(inputdf, 
                                                    iterations = resample.nreps
                                           ){
                                             furrr::future_map(seq(1, iterations), function(
                                               i
                                             ){
                                               if (i == 1) {
                                                 return(inputdf)
                                               } else {
                                                 mutate(inputdf,
                                                        dept.var = sample(unlist(dplyr::select_at(inputdf, "dept.var")),
                                                                          replace = T
                                                        )
                                                 )
                                               }
                                             })
                                           })

## Apply the proscribed stats test ====
nested_test_results <- furrr::future_map(seq_along(df_and_counterfactual), 
                                         function(i){
                                           
                                           df.list <- df_and_counterfactual[[i]]
                                           
                                           df.main.formula <- as.formula(all.tests[i, "Model"])
                                           df.rand.formula <- as.formula(all.tests[i, "Random"])
                                           
                                           furrr::future_map(df.list, function(df, main.formula = df.main.formula, rand.formula = df.rand.formula){
                                             
                                             # get rid of NA in DV ----
                                             input.df <- df[!is.na(df$dept.var), ]
                                             
                                             # test ----
                                             # In some situations this will fail with  "Error in MEEM(object, conLin, control$niterEM) : \n  Singularity in backsolve at level 0, block 1\n"
                                             
                                             # the result of nlme will be a list unless there was an error in which case it will be a character type
                                             # if fm is a character type then we'll make a new random df on the fly UNLESS j = 1 in which case we'll provide an error message
                                             
                                             fm <- try(nlme::lme(
                                               main.formula,
                                               # dept.var ~ Time * Condition,
                                               random = rand.formula,
                                               # random = ~1 | Experiment,
                                               method = "REML",
                                               data = input.df
                                             ))
                                             
                                             # make up replacement value on the fly. ----
                                             if (typeof(fm) == "character") {
                                               if (j == 1) {
                                                 warning("\n\nThe input data produced an error. 
                \nIt could not be fit by nlme::lme() 
                \nConsider fitting it manually before trying again.")
                                               } else {
                                                 counter <- 1
                                                 while (counter > 100 & typeof(fm) == "character") {
                                                   input.df <- mutate(preped.df,
                                                                      dept.var = sample(unlist(dplyr::select_at(preped.df, "dept.var")),
                                                                                        replace = T
                                                                      )
                                                   )
                                                   
                                                   fm <- try(nlme::lme(
                                                     as.formula(all.tests[i, "Model"]),
                                                     # dept.var ~ Time * Condition,
                                                     random = as.formula(all.tests[i, "Random"]),
                                                     # random = ~1 | Experiment,
                                                     method = "REML",
                                                     data = input.df
                                                   ))
                                                 }
                                               }
                                               
                                             }
                                             
                                             return(fm)
                                           })
                                         }) 


## Make tables of asymptotic test statistics ====
asymptotic_res <- furrr::future_map(nested_test_results, function(test_set){
  anova.lme(test_set[[1]])
})

## Make tables of empirical test statistics ====

### get all the f values in a single df for each test ####
resampled_distribution <- furrr::future_map(nested_test_results, function(test_set){
  # test_set <- nested_test_results[[1]]
  
  # join into dataframe (asymptotic == row 1)
  fvals <- furrr::future_map(test_set, function(fm){
    # if there was an error in solving, e.g. Singularity in backsolve at level 0, we want to drop this value.
    if (typeof(fm) == "character"){
      table <- NA
    } else {
      table <- try(anova.lme(fm))[, "F-value"]      
    }
    return(table)
  })
  
  fvals <- fvals %>% 
    reduce(rbind) %>% 
    as.data.frame()
  
  # if there were any errors there will be a blank in the dataframe. Drop it.
  fvals <- fvals[!is.na(fvals$V1), ]
  
  # apply appropriate labels
  names(fvals) <- anova.lme(test_set[[1]]) %>% rownames()
  
  return(fvals)
})

### convert into empirical p values ####
resampled_pvals <- furrr::future_map(resampled_distribution, function(resampled_f){
  pvals <- resampled_f[1, ]
  
  for (i in seq(1, ncol(pvals))){
    pvals[1, i] <- mean(resampled_f[1, i] <= resampled_f[, i])
    
  }
  
  return(pvals)
})

### Add resampled p values to asymptotic
asymp_resamp_stats <- furrr::future_map(seq_along(asymptotic_res), function(i){
  
  table <- asymptotic_res[[i]]
  resampled_p <- resampled_pvals[[i]]
    
  table$`ep-value` <- NA
  table$`ep-value` <- as.vector(t(resampled_p))
  
  return(table)
})

### Add annotations
asymp_resamp_stats_annotated <- furrr::future_map(seq_along(asymp_resamp_stats), function(i){
  
  temp <- asymp_resamp_stats[[i]]
  
  temp$parameter <- rownames(temp)
  temp$response <- all.tests[i, "DV"]
  temp$groups <- all.tests[i, "Groups"]
  
  # if it's class anova.lme then selection with new cols causes it to choke.
  temp <- as.data.frame(temp)
  # re order to make sorting easier
  temp <- temp[, c(7:8, 6,1:5)]
  
  return(temp)
  
})

### Make summary stats table 
all_stats <- do.call(rbind, asymp_resamp_stats_annotated)
}


### Make paramter estimates and summary table 
param_estimates <- map(seq_along(nested_test_results), function(i){
  fm <- nested_test_results[[i]][[1]]
  params <- tidy(fm)
  # params <- tidy(test.results[[i]]$res[[1]])
  params <- params %>% dplyr::select(term, estimate) %>% filter(term != "(Intercept)") %>% distinct() %>% rename(Term = term)
  params <- rbind(data.frame(Term = c("(Intercept)"), estimate = c(NA)),
                  params)
  
  params <- params %>% mutate(
    DV = all.tests[i, "DV"],
    Groups = all.tests[i, "Groups"])
  
  params <- params[, c("DV", "Groups", "Term", "estimate")]
})

all_param_estimates <- do.call(rbind, param_estimates)

## Cache all Resampling objects ====


## Write out tables ====
if (write.resample.results){
  write.csv(all_param_estimates, file = here("data", "stats_no_60", "all_param_estimates.csv"))
  
  write.csv(all_stats, file = here("data", "stats_no_60", "all_stats.csv"), row.names = F)
  
  walk(asymp_resamp_stats_annotated, function(df){
    
    file.name <- paste(
      as.character(df[1, "response"]), 
      "-",
      as.character(df[1, "groups"]),
      ".csv",
      sep = "")  
    
    write.csv(df, file = here("data", "stats_no_60", file.name), row.names = F)
  })
  
  
}
```



## what if phase is continuous?
```{r eval=FALSE, include=FALSE}

# WARNING
# Close everything else before running this bit!
# Running required ~ 11GB ram for 1000 resamplings


## Make counterfactual dfs and run tests ====
if (make.resample.results){
  set.seed(657984118)
  
## split all.tests up into a list of dfs ====
all.tests.list <- map(1:nrow(all.tests), function(i){
  all.tests[i, ]
})

## pull out the relevant data to shuffle ====
prepped.df <- furrr::future_map(seq_along(all.tests.list), 
                                function(i, 
                                         in.data = M.clean){
                                  
                                  test.info <- all.tests.list[[i]]
                                  
                                  data.slice <- ready_data_to_test(
                                    input.df = in.data,
                                    dept.var = as.character(test.info[, "DV"]),
                                    vis.conditions = str_split(string = as.character(test.info[, "Groups"]), pattern = "_")[[1]], # Split up char string.
                                    use.times = c(0, 20, 40, 60),
                                    use.pseudorep.diff.tol = T,
                                    use.diff.tol = 0.5,
                                    obs.is.network = as.logical(test.info[, "Obs.Net"]))
                                  
                                  
                                })


## Convert condition into as continuous version of phase
walk(seq_along(prepped.df), function(i){
  temp <- prepped.df[[i]]
  temp[temp$Condition %in% c("PS.0.High.Amp", "PS.0", "PS.0.orig"), "Condition"] <- "0"
  temp[temp$Condition %in% c("PS.22", "PS.22.High.Amp", "PS.22.orig"), "Condition"] <- "0.0625"
  temp[temp$Condition %in% c("PS.45", "PS.45.orig"), "Condition"] <- "0.125"
  temp[temp$Condition %in% c("PS.90", "PS.90.HA", "PS.90.HA.Cd", "PS.90.orig"), "Condition"] <- "0.25"
  temp[temp$Condition %in% c("PS.180.orig"), "Condition"] <- "0.5"
  
  temp$Condition <- as.numeric(temp$Condition)
  
  prepped.df[[i]] <<- temp
})

## Make up all the datasets to be used ====
# The first one is the actual data
df_and_counterfactual <- furrr::future_map(prepped.df, 
                                           function(inputdf, 
                                                    iterations = resample.nreps
                                           ){
                                             furrr::future_map(seq(1, iterations), function(
                                               i
                                             ){
                                               if (i == 1) {
                                                 return(inputdf)
                                               } else {
                                                 mutate(inputdf,
                                                        dept.var = sample(unlist(dplyr::select_at(inputdf, "dept.var")),
                                                                          replace = T
                                                        )
                                                 )
                                               }
                                             })
                                           })

## Apply the proscribed stats test ====
nested_test_results <- furrr::future_map(seq_along(df_and_counterfactual), 
                                         function(i){
                                           
                                           df.list <- df_and_counterfactual[[i]]
                                           
                                           df.main.formula <- as.formula(all.tests[i, "Model"])
                                           df.rand.formula <- as.formula(all.tests[i, "Random"])
                                           
                                           furrr::future_map(df.list, function(df, main.formula = df.main.formula, rand.formula = df.rand.formula){
                                             
                                             # get rid of NA in DV ----
                                             input.df <- df[!is.na(df$dept.var), ]
                                             
                                             # test ----
                                             # In some situations this will fail with  "Error in MEEM(object, conLin, control$niterEM) : \n  Singularity in backsolve at level 0, block 1\n"
                                             
                                             # the result of nlme will be a list unless there was an error in which case it will be a character type
                                             # if fm is a character type then we'll make a new random df on the fly UNLESS j = 1 in which case we'll provide an error message
                                             
                                             fm <- try(nlme::lme(
                                               main.formula,
                                               # dept.var ~ Time * Condition,
                                               random = rand.formula,
                                               # random = ~1 | Experiment,
                                               method = "REML",
                                               data = input.df
                                             ))
                                             
                                             # make up replacement value on the fly. ----
                                             if (typeof(fm) == "character") {
                                               if (j == 1) {
                                                 warning("\n\nThe input data produced an error. 
                \nIt could not be fit by nlme::lme() 
                \nConsider fitting it manually before trying again.")
                                               } else {
                                                 counter <- 1
                                                 while (counter > 100 & typeof(fm) == "character") {
                                                   input.df <- mutate(preped.df,
                                                                      dept.var = sample(unlist(dplyr::select_at(preped.df, "dept.var")),
                                                                                        replace = T
                                                                      )
                                                   )
                                                   
                                                   fm <- try(nlme::lme(
                                                     as.formula(all.tests[i, "Model"]),
                                                     # dept.var ~ Time * Condition,
                                                     random = as.formula(all.tests[i, "Random"]),
                                                     # random = ~1 | Experiment,
                                                     method = "REML",
                                                     data = input.df
                                                   ))
                                                 }
                                               }
                                               
                                             }
                                             
                                             return(fm)
                                           })
                                         }) 


## Make tables of asymptotic test statistics ====
asymptotic_res <- furrr::future_map(nested_test_results, function(test_set){
  try(anova.lme(test_set[[1]]))
})

## Make tables of empirical test statistics ====

### get all the f values in a single df for each test ####
resampled_distribution <- furrr::future_map(nested_test_results, function(test_set){
  # test_set <- nested_test_results[[1]]
  if (typeof(test_set[[1]]) != "character"){
    # join into dataframe (asymptotic == row 1)
  fvals <- furrr::future_map(test_set, function(fm){
    # if there was an error in solving, e.g. Singularity in backsolve at level 0, we want to drop this value.
    if (typeof(fm) == "character"){
      table <- NA
    } else {
      table <- try(anova.lme(fm))[, "F-value"]      
    }
    return(table)
  })
  
  fvals <- fvals %>% 
    reduce(rbind) %>% 
    as.data.frame()
  
  # if there were any errors there will be a blank in the dataframe. Drop it.
  fvals <- fvals[!is.na(fvals$V1), ]
  
  # apply appropriate labels
  names(fvals) <- anova.lme(test_set[[1]]) %>% rownames()
  } else {
    fvals <- NA
  }

  
  
  return(fvals)
})

### convert into empirical p values ####
resampled_pvals <- furrr::future_map(resampled_distribution, function(resampled_f){
  if (!is.na(resampled_f[[1]])){
    pvals <- resampled_f[1, ]
    
    for (i in seq(1, ncol(pvals))){
      pvals[1, i] <- mean(resampled_f[1, i] <= resampled_f[, i])
      
    }
    
  } else {
    pvals <- NA
  }
  
  
  return(pvals)
})

### Add resampled p values to asymptotic
asymp_resamp_stats <- furrr::future_map(seq_along(asymptotic_res), function(i){
  
  table <- asymptotic_res[[i]]
  resampled_p <- resampled_pvals[[i]]
    
  table$`ep-value` <- NA
  table$`ep-value` <- as.vector(t(resampled_p))
  
  return(table)
})

### Add annotations
asymp_resamp_stats_annotated <- furrr::future_map(seq_along(asymp_resamp_stats), function(i){
  if (!is.na(asymp_resamp_stats[[i]]$`ep-value`)){
  temp <- asymp_resamp_stats[[i]]
  
  temp$parameter <- rownames(temp)
  temp$response <- all.tests[i, "DV"]
  temp$groups <- all.tests[i, "Groups"]
  
  # if it's class anova.lme then selection with new cols causes it to choke.
  temp <- as.data.frame(temp)
  # re order to make sorting easier
  temp <- temp[, c(7:8, 6,1:5)]
    
  } else {
    temp <- NA
    
  }
  
  
  
  return(temp)
  
})

### Make summary stats table 
all_stats <- do.call(rbind, asymp_resamp_stats_annotated)
}


### Make paramter estimates and summary table 
param_estimates <- map(seq_along(nested_test_results), function(i){
  
  if (typeof(nested_test_results[[i]][[1]]) != "character"){
    fm <- nested_test_results[[i]][[1]]
  params <- tidy(fm)
  # params <- tidy(test.results[[i]]$res[[1]])
  params <- params %>% dplyr::select(term, estimate) %>% filter(term != "(Intercept)") %>% distinct() %>% rename(Term = term)
  params <- rbind(data.frame(Term = c("(Intercept)"), estimate = c(NA)),
                  params)
  
  params <- params %>% mutate(
    DV = all.tests[i, "DV"],
    Groups = all.tests[i, "Groups"])
  
  params <- params[, c("DV", "Groups", "Term", "estimate")]
  } else {
    params <- NA
  }
  return(params)
  
})

all_param_estimates <- do.call(rbind, param_estimates)

## Cache all Resampling objects ====


## Write out tables ====
if (write.resample.results){
  write.csv(all_param_estimates, file = here("data", "stats_cont", "all_param_estimates.csv"))
  
  write.csv(all_stats, file = here("data", "stats_cont", "all_stats.csv"), row.names = F)
  
  # walk(asymp_resamp_stats_annotated, function(df){
  #   
  #   if (!is.na(typeof(df[[1]]))){
  #     
  #     file.name <- paste(
  #       as.character(df[1, "response"]), 
  #       "-",
  #       as.character(df[1, "groups"]),
  #       ".csv",
  #       sep = "")  
  #     
  #     write.csv(df, file = here("data", "stats_cont", file.name), row.names = F)
  #     
  #   } 
  # })
  
  
}


```


## Dave's email

From: "Schulz, David J." <schulzd@missouri.edu>
Date: Thursday, June 13, 2019 at 12:05 PM
To: "Kick, Daniel R. (MU-Student)" <drk8b9@mail.missouri.edu>
Subject: One more set of figures, revisited

Daniel,
 
>I would like to see the combined delta GJ across experimental groups where we combine everything that has the same phase (skip the inverted waveform).  So in other words, if you could take Figure 5 and collapse it to a 1x5 where there is no factor of stimulus type.  I would like to see this, formatted to replace the inverted waveform row.
 
Thanks,
Dave

```{r eval=FALSE, include=FALSE}
d <- add_Stim.type_Phase.angle(d = M.d)
yvar = "rc"
d$inter <- paste0(d$Experiment, ".", d$Inj_Cell)


d$Condition <- factor(d$Condition, levels = c(
  "PS.0.orig",
  "PS.22.orig",
  "PS.45.orig",
  "PS.90.orig",
  "PS.180.orig",
  
  "PS.0",
  "PS.22",
  "PS.45",
  "PS.90",
  
  "PS.0.High.Amp",
  "PS.22.High.Amp",
  
  "Inv",
  "PS.0.TEA",
  "Silent.53mV"
))

d.pooled <- d %>% filter(Condition %in% c(
  "PS.0",
  "PS.22",
  "PS.45",
  "PS.90",
  
  "PS.0.High.Amp",
  "PS.22.High.Amp",
  
  "PS.0.orig",
  "PS.22.orig",
  "PS.45.orig",
  "PS.90.orig",
  "PS.180.orig"
))
d.pooled$Stim.type <- "All"

d <- full_join(d, d.pooled)
d$Stim.type <- as.factor(d$Stim.type)

d$Stim.type <- factor(d$Stim.type, levels = c(  "Inversion",
                                                "Standardized",       
                                                "Naturalistic",     
                                                "High Voltage",
                                                "All",
                                                "TEA",
                                                "Silent" 
))


d$Condition <- as.character(d$Condition)
d[d$Stim.type == "All" & d$Phase.angle == "0", "Condition"] <- "All.0"
d[d$Stim.type == "All" & d$Phase.angle == "22.5", "Condition"] <- "All.22.5"
d[d$Stim.type == "All" & d$Phase.angle == "45", "Condition"] <- "All.45"
d[d$Stim.type == "All" & d$Phase.angle == "90", "Condition"] <- "All.90"
d[d$Stim.type == "All" & d$Phase.angle == "180", "Condition"] <- "All.180"

d$Condition <- as.factor(d$Condition)
d$Condition <- factor(d$Condition, levels = c(
  "PS.0.orig",
  "PS.22.orig",
  "PS.45.orig",
  "PS.90.orig",
  "PS.180.orig",
  
  "PS.0",
  "PS.22",
  "PS.45",
  "PS.90",
  
  "PS.0.High.Amp",
  "PS.22.High.Amp",
  
  "All.0",
  "All.22.5",
  "All.45",
  "All.90",
  "All.180",
  
  
  "Silent.53mV",
  "PS.0.TEA",
  "Inv"
))

ggplot(d[
  (d$Condition %in% c(
    # "Silent.53mV",
    # "PS.0.TEA",
    # "Inv",
    
    "PS.0",
    "PS.22",
    "PS.45",
    "PS.90",
    
    "PS.0.High.Amp",
    "PS.22.High.Amp",
    
    "PS.0.orig",
    "PS.22.orig",
    "PS.45.orig",
    "PS.90.orig",
    "PS.180.orig",
    
    "All.0",
    "All.22.5",
    "All.45",
    "All.90",
    "All.180"
    
  )),], aes_string("Time", yvar, fill = "Condition"))+
  geom_hline(yintercept = 0, color = "black")+
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "ribbon", alpha = 0.2)+
  geom_pointline(aes(group = inter, color = Condition))+
  stat_summary(fun.y = mean, geom = "point", aes(color = Condition), size = 5, color = "white", alpha = 0.7) +
  stat_summary( fun.y = mean, geom = "line", aes(color = Condition), size = 1, linetype = 1 , color = "white") +
  
  kickme()+
  # coord_cartesian(ylim = c(-2, 4))+
  labs(y = "Coupling Resistance")+
  facet_grid(Stim.type ~ Phase.angle)+
  scale_color_manual(values = c(
    "#77A8C8", "#046FB5", "#046FB5", "#003856", "#003856", 
    "#41AE77", "#006E2C", "#006E2C", "#00451B", 
    "#FC8D58", "#EF6548", #"#D43120", "#B40001", "#810000", 
    "#77A8C8", "#046FB5", "#046FB5", "#003856", "#003856")    
  )+
  scale_fill_manual(values = c(
    "#77A8C8", "#046FB5", "#046FB5", "#003856", "#003856", 
    "#41AE77", "#006E2C", "#006E2C", "#00451B", 
    "#FC8D58", "#EF6548", #"#D43120", "#B40001", "#810000", 
    "#77A8C8", "#046FB5", "#046FB5", "#003856", "#003856"
  ))
```

```{r eval=FALSE, include=FALSE}
ggsave(
      "fig5_pooled_means.pdf",
      plot = ggplot2::last_plot(),
      device = NULL,
      path = paste0(getwd(), "/data/figures"),
width = 11, height = 8.5,
      # units = c("in", "cm", "mm"),
      dpi = 75#, limitsize = TRUE, ...
    )
```





>And perhaps we can see this one with mean and median as the population measure (two separate versions). 

```{r eval=FALSE, include=FALSE}
# d <- add_Stim.type_Phase.angle(d = M.d)
# yvar = "rc"
# d$inter <- paste0(d$Experiment, ".", d$Inj_Cell)
#
#
# d$Condition <- factor(d$Condition, levels = c(
#   "PS.0.orig",
#   "PS.22.orig",
#   "PS.45.orig",
#   "PS.90.orig",
#   "PS.180.orig",
#
#   "PS.0",
#   "PS.22",
#   "PS.45",
#   "PS.90",
#
#   "PS.0.High.Amp",
#   "PS.22.High.Amp",
#
#   "Inv",
#   "PS.0.TEA",
#   "Silent.53mV"
# ))
#
# d.pooled <- d %>% filter(Condition %in% c(
#   "PS.0",
#   "PS.22",
#   "PS.45",
#   "PS.90",
#
#   "PS.0.High.Amp",
#   "PS.22.High.Amp",
#
#   "PS.0.orig",
#   "PS.22.orig",
#   "PS.45.orig",
#   "PS.90.orig",
#   "PS.180.orig"
# ))
# d.pooled$Stim.type <- "All"
#
# d <- full_join(d, d.pooled)
# d$Stim.type <- as.factor(d$Stim.type)
#
# d$Stim.type <- factor(d$Stim.type, levels = c(  "Inversion",
#                                                 "Standardized",
#                                                 "Naturalistic",
#                                                 "High Voltage",
#                                                 "All",
#                                                 "TEA",
#                                                 "Silent"
# ))
#
#
# d$Condition <- as.character(d$Condition)
# d[d$Stim.type == "All" & d$Phase.angle == "0", "Condition"] <- "All.0"
# d[d$Stim.type == "All" & d$Phase.angle == "22.5", "Condition"] <- "All.22.5"
# d[d$Stim.type == "All" & d$Phase.angle == "45", "Condition"] <- "All.45"
# d[d$Stim.type == "All" & d$Phase.angle == "90", "Condition"] <- "All.90"
# d[d$Stim.type == "All" & d$Phase.angle == "180", "Condition"] <- "All.180"
#
# d$Condition <- as.factor(d$Condition)
# d$Condition <- factor(d$Condition, levels = c(
#   "PS.0.orig",
#   "PS.22.orig",
#   "PS.45.orig",
#   "PS.90.orig",
#   "PS.180.orig",
#
#   "PS.0",
#   "PS.22",
#   "PS.45",
#   "PS.90",
#
#   "PS.0.High.Amp",
#   "PS.22.High.Amp",
#
#   "All.0",
#   "All.22.5",
#   "All.45",
#   "All.90",
#   "All.180",
#
#
#   "Silent.53mV",
#   "PS.0.TEA",
#   "Inv"
# ))
#
# use.conditions <- c(
#     # "Silent.53mV",
#     # "PS.0.TEA",
#     # "Inv",
#
#     "PS.0",
#     "PS.22",
#     "PS.45",
#     "PS.90",
#
#     "PS.0.High.Amp",
#     "PS.22.High.Amp",
#
#     "PS.0.orig",
#     "PS.22.orig",
#     "PS.45.orig",
#     "PS.90.orig",
#     "PS.180.orig",
#
#     "All.0",
#     "All.22.5",
#     "All.45",
#     "All.90",
#     "All.180"
#
#   )
#
# ggplot(d[
#   (d$Condition %in% use.conditions),], aes_string("Time", yvar, fill = "Condition"))+
#   geom_hline(yintercept = 0, color = "black")+
#   stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "ribbon", alpha = 0.2)+
#   geom_pointline(aes(group = inter, color = Condition))+
#   stat_summary(data = filter(d[d$Condition %in% use.conditions, ], Stim.type != "All"), fun.y = mean, geom = "point", aes(color = Condition), size = 5, color = "white", alpha = 0.7) +
#   stat_summary(data = filter(d[d$Condition %in% use.conditions, ], Stim.type != "All"), fun.y = mean, geom = "line", aes(color = Condition), size = 1, linetype = 1 , color = "white") +
#   # last row uses medians
#   stat_summary(data = filter(d[d$Condition %in% use.conditions, ], Stim.type == "All"), fun.y = median, geom = "point", aes(color = Condition), size = 5, color = "white", alpha = 0.7) +
#   stat_summary(data = filter(d[d$Condition %in% use.conditions, ], Stim.type == "All"), fun.y = median, geom = "line", aes(color = Condition), size = 1, linetype = 1 , color = "white") +
#
#   kickme()+
#   # coord_cartesian(ylim = c(-2, 4))+
#   labs(y = "Coupling Resistance")+
#   facet_grid(Stim.type ~ Phase.angle)+
#   scale_color_manual(values = c(
#     "#77A8C8", "#046FB5", "#046FB5", "#003856", "#003856",
#     "#41AE77", "#006E2C", "#006E2C", "#00451B",
#     "#FC8D58", "#EF6548", #"#D43120", "#B40001", "#810000",
#     "#77A8C8", "#046FB5", "#046FB5", "#003856", "#003856")
#   )+
#   scale_fill_manual(values = c(
#     "#77A8C8", "#046FB5", "#046FB5", "#003856", "#003856",
#     "#41AE77", "#006E2C", "#006E2C", "#00451B",
#     "#FC8D58", "#EF6548", #"#D43120", "#B40001", "#810000",
#     "#77A8C8", "#046FB5", "#046FB5", "#003856", "#003856"
#   ))


```

```{r eval=FALSE, include=FALSE}
# ggsave(
#       "fig5_pooled_medians.pdf",
#       plot = ggplot2::last_plot(),
#       device = NULL,
#       path = paste0(getwd(), "/data/figures"),
# width = 11, height = 8.5,
#       # units = c("in", "cm", "mm"),
#       dpi = 75#, limitsize = TRUE, ...
#     )
```

```{r eval=FALSE, include=FALSE}

# cowplot::plot_grid(plotlist = list(
# ggplot(filter(d[d$Condition %in% use.conditions, ], Stim.type == "Naturalistic"), aes(x = Time, y = rc, color = Condition))+
#   geom_hline(yintercept = 0, color = "black")+
#   stat_summary(fun.y = mean, geom = "point", aes(color = Condition), size = 5, alpha = 0.7) +
#   stat_summary(fun.y = mean, geom = "line", aes(color = Condition), size = 1, linetype = 1 )+
#   facet_grid(Stim.type~.)+
#   kickme(),
# 
# 
# ggplot(filter(d[d$Condition %in% use.conditions, ], Stim.type == "Standardized"), aes(x = Time, y = rc, color = Condition))+
#   geom_hline(yintercept = 0, color = "black")+
#   stat_summary(fun.y = mean, geom = "point", aes(color = Condition), size = 5, alpha = 0.7) +
#   stat_summary(fun.y = mean, geom = "line", aes(color = Condition), size = 1, linetype = 1 )+
#   facet_grid(Stim.type~.)+
#   kickme()
# 
# ))
```


Supplemental figure, pairs with Fig 2
```{r eval=FALSE, include=FALSE}
d <- add_Stim.type_Phase.angle(d = M.d.gj)
yvar = "gj"
d$inter <- paste0(d$Experiment, ".", d$Inj_Cell)

# labeli2 <- function(variable, value){
#   value <- droplevels(value)
#   names_li <- list(
#     "PS.0.orig"= "0 Natural",
#     "PS.22.orig" = "22.5 Natural",
#     "PS.45.orig" = "45 Natural",
#     "PS.90.orig" = "90 Natural",
#     "PS.180.orig" = "180 Natural",
#     
#     "PS.0" = "0",
#     "PS.22" = "22.5",
#     "PS.45" = "45",
#     "PS.90" = "90",
#     
#     "PS.0.High.Amp" = "0 High V",
#     "PS.22.High.Amp" = "22.5 High V",
#     
#     "Inv" = "0 Inverted",
#     "PS.0.TEA" = "0 TEA",
#     "Silent.53mV" = "Silent"
#     )
#   return(names_li[value])
# }

d$Condition <- factor(d$Condition, levels = c(
  # "PS.0.orig",
  # "PS.22.orig",
  # "PS.45.orig",
  # "PS.90.orig",
  # "PS.180.orig",
  # 
  # "PS.0",
  # "PS.22",
  # "PS.45",
  # "PS.90",
  # 
  # "PS.0.High.Amp",
  # "PS.22.High.Amp",
  
  "Inv",
  # "PS.0.TEA",
  "Silent.53mV"
))




ggplot(d[
  (d$Condition %in% c(
    "Silent.53mV",
    # "PS.0.TEA",
    "Inv"#,
    
    # "PS.0",
    # "PS.22",
    # "PS.45",
    # "PS.90",
    # 
    # "PS.0.High.Amp",
    # "PS.22.High.Amp",
    # 
    # "PS.0.orig",
    # "PS.22.orig",
    # "PS.45.orig",
    # "PS.90.orig",
    # "PS.180.orig"
  )),], aes_string("Time", yvar, fill = "Condition"))+
  geom_hline(yintercept = 0, color = "black")+
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "ribbon", alpha = 0.5)+
  # geom_ribbon(aes(ymin=0, ymax=Condition.Mean), alpha = 0.5)+
  # geom_ribbon(aes(ymin=-4, ymax=0), fill = "Black")+
  # stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "ribbon", alpha = 0.02)+
  geom_pointline(aes(group = inter, color = Condition))+
  stat_summary(fun.y = mean, geom = "point", aes(color = Condition), size = 5, color = "white", alpha = 0.7) +
  stat_summary( fun.y = mean, geom = "line", aes(color = Condition), size = 1, linetype = 1 , color = "white") +
  kickme()+
  # coord_cartesian(ylim = c(-2, 4))+
  labs(y = "Coupling Resistance")+
  facet_grid(. ~ Condition)+
  scale_color_manual(values = c(
    # "#77A8C8", "#046FB5", "#046FB5", "#003856", "#003856", 
    # "#41AE77", "#006E2C", "#006E2C", "#00451B", 
    # "#FC8D58", "#EF6548", #"#D43120", "#B40001", "#810000", 
    "#CD1256", "#E32D91"
    ))+
  scale_fill_manual(values = c(
    # "#77A8C8", "#046FB5", "#046FB5", "#003856", "#003856", 
    # "#41AE77", "#006E2C", "#006E2C", "#00451B", 
    # "#FC8D58", "#EF6548", #"#D43120", "#B40001", "#810000", 
    "#CD1256", "#E32D91"
  ))
# RColorBrewer::brewer.pal(9, "Blues")[5:9],
# RColorBrewer::brewer.pal(9, "Purples")[6:9],
# RColorBrewer::brewer.pal(9, "Reds")[8:9],
# RColorBrewer::brewer.pal(9, "Blues")[9]


```

```{r eval=FALSE, include=FALSE}
ggsave(
      "fig2_sup.pdf",
      plot = ggplot2::last_plot(),
      device = NULL,
      path = paste0(getwd(), "/data/figures"),
width = 11, height = 8.5,
      # units = c("in", "cm", "mm"),
      dpi = 75#, limitsize = TRUE, ...
    )
```


Quick answers for djs

```{r eval=FALSE, include=FALSE}
M.gj %>% dplyr::select(c("Time", "gj")) %>% filter(Time == 0) %>% summary()
```



```{r eval=FALSE, include=FALSE}
M.d.gj %>% 
  dplyr::select(c("Time", "Condition", "gj")) %>% 
  filter(Time == 60 & 
           (Condition == "PS.0" | 
              Condition == "PS.22." | 
              Condition == "PS.45" | 
              Condition == "PS.90" | 
              Condition == "PS.0.High.Amp" | 
              Condition == "PS.22.High.Amp") ) %>% 
  group_by(Condition) %>% 
  summarise_at(vars(-Time), funs(mean(., na.rm=TRUE)))

```


stats tables lme
Controlled
```{r perform resampling, eval=FALSE}
if (resample.results == TRUE){
  tic1 <- Sys.time()
  me_cell <- purrr::map(c("r11", "r1", "cc"
                          # , "htk.peak.nA", "a.peak.nA"
                          ), function(x) {
    run_standardized_lme_resample_Phase(
      response.var = x,
      input.df = M[M$Condition %in% c("PS.0", "PS.22", "PS.45", "PS.90"), ],
      nreps = resample.nreps,
      use.seed = 432431,
      mute.completion = TRUE,
      mute.time = FALSE
    )
  })
  
  me_exps <- purrr::map(c("rc", "gj"), function(x) {
    run_standardized_lme_resample_Phase(
      response.var = x,
      input.df = M.gj[M.gj$Condition %in% c("PS.0", "PS.22", "PS.45", "PS.90"), ],
      nreps = resample.nreps,
      use.seed = 432431,
      mute.completion = TRUE,
      mute.time = FALSE
    )
  })
  toc1 <- Sys.time()
  print(toc1 - tic1)
  
  # Restructure into a single list of all outputs
  me_all <- list()
  walk(seq_along(me_cell), function(X){ me_all[[length(me_all)+1]] <<- me_cell[[X]] })
  walk(seq_along(me_exps), function(X){ me_all[[length(me_all)+1]] <<- me_exps[[X]] })
  
  saveRDS(me_all, file = paste0(getwd(), "/data/output/", "rPS0_PS90_model_results", ".rds"))
  write.csv(me_all, file = paste0(getwd(), "/data/output/", "rPS0_PS90_model_results", ".csv"))
} else {
  me_all <- readRDS(paste0(getwd(), "/data/", "rPS0_PS90_model_results", ".rds"))
}

```


```{r calc empirical p, eval=FALSE}
# Main effect empirical p values
measures <- c("r11", "r1", 
              "cc", 
              # "htk.peak.nA", "a.peak.nA",
              "rc", 
              "gj")
out <- as.data.frame(matrix(ncol = 4, nrow = length(measures)))
names(out) <- c("Intercept", "Time", "Phase", "Time:Phase")
rownames(out) <- measures

walk(seq_along(measures), function(i){
  walk(1:4, function(j){
    out[i, j] <<- one_tail_to_epval(input.array = me_all[[i]][,j], tail = "upper")
  })
})


out.holm <- t(out) %>% as.data.frame()
walk(1:ncol(out.holm), function(i){
  out.holm[,i] <<- p.adjust(out.holm[,i], method = "holm") 
})
out.holm <- t(out.holm) %>% as.data.frame()


knitr::kable(out)
knitr::kable(out.holm)

# write.csv(out, paste0(getwd(), "/epvals_phase.csv"))
# write.csv(out.holm, paste0(getwd(), "/epvals_holm_phase.csv"))

write.csv(out, paste0(getwd(), "/data/output/", "rPS0_PS90_model_pvals", ".csv"))
write.csv(out.holm, paste0(getwd(), "/data/output/", "rPS0_PS90_model_pvals_holm", ".csv"))
# write.csv(out.holm, paste0("C:/Users/Daniel/Desktop/epvals_holm_phase.csv"))

```


Naturalistic
```{r perform resampling, eval=FALSE}
if (resample.results == TRUE){
  tic1 <- Sys.time()
  me_cell <- purrr::map(c("r11", "r1", "cc"
                          # , "htk.peak.nA", "a.peak.nA"
                          ), function(x) {
    run_standardized_lme_resample_Phase_Orig(
      response.var = x,
      input.df = M[M$Condition %in% c("PS.0.orig",
    "PS.22.orig",
    "PS.45.orig",
    "PS.90.orig",
    "PS.180.orig"), ],
      nreps = resample.nreps,
      use.seed = 432431,
      mute.completion = TRUE,
      mute.time = FALSE
    )
  })
  
  me_exps <- purrr::map(c("rc", "gj"), function(x) {
    run_standardized_lme_resample_Phase_Orig(
      response.var = x,
      input.df = M.gj[M.gj$Condition %in% c("PS.0.orig",
    "PS.22.orig",
    "PS.45.orig",
    "PS.90.orig",
    "PS.180.orig"), ],
      nreps = resample.nreps,
      use.seed = 432431,
      mute.completion = TRUE,
      mute.time = FALSE
    )
  })
  toc1 <- Sys.time()
  print(toc1 - tic1)
  
  # Restructure into a single list of all outputs
  me_all <- list()
  walk(seq_along(me_cell), function(X){ me_all[[length(me_all)+1]] <<- me_cell[[X]] })
  walk(seq_along(me_exps), function(X){ me_all[[length(me_all)+1]] <<- me_exps[[X]] })
  
  saveRDS(me_all, file = paste0(getwd(), "/data/output/", "rOrig0_Orig180_model_results", ".rds"))
  write.csv(me_all, file = paste0(getwd(), "/data/output/", "rOrig0_Orig180_model_results", ".csv"))
  
} else {
  me_all <- readRDS(paste0(getwd(), "/data/output/", "rOrig0_Orig180_model_results", ".rds"))
}

```


```{r calc empirical p, eval=FALSE}
# Main effect empirical p values
measures <- c("r11", "r1", 
              "cc", 
              # "htk.peak.nA", "a.peak.nA",
              "rc", 
              "gj")
out <- as.data.frame(matrix(ncol = 4, nrow = length(measures)))
names(out) <- c("Intercept", "Time", "Phase", "Time:Phase")
rownames(out) <- measures

walk(seq_along(measures), function(i){
  walk(1:4, function(j){
    out[i, j] <<- one_tail_to_epval(input.array = me_all[[i]][,j], tail = "upper")
  })
})


out.holm <- t(out) %>% as.data.frame()
walk(1:ncol(out.holm), function(i){
  out.holm[,i] <<- p.adjust(out.holm[,i], method = "holm") 
})
out.holm <- t(out.holm) %>% as.data.frame()


knitr::kable(out)
knitr::kable(out.holm)

# write.csv(out, paste0(getwd(), "/epvals_phase.csv"))
# write.csv(out.holm, paste0(getwd(), "/epvals_holm_phase.csv"))

write.csv(out, paste0(getwd(), "/data/output/", "rOrig0_Orig180_model_pvals", ".csv"))
write.csv(out.holm, paste0(getwd(), "/data/output/", "rOrig0_Orig180_model_pvals_holm", ".csv"))

```




## resampling
High Amp
```{r eval=FALSE, include=FALSE}

run_standardized_lme_resample_HA <- function(response.var = "cc",
                                          input.df = M[M$Condition %in% c("PS.0.High.Amp", "PS.22.High.Amp"), ],
                                          nreps = 1e4,
                                          use.seed = 432431,
                                          mute.completion = FALSE,
                                          mute.time = FALSE) {
  #for debugging
  if (F == T){
    response.var = "cc"
    input.df = M[M$Condition %in% c("PS.0.High.Amp", "PS.22.High.Amp"), ]
    nreps = 100
    use.seed = 432431
    mute.completion = FALSE
    mute.time = FALSE
  }
  
  tic <- Sys.time()
  
  # Transform the data so that it's ready for the test
  input.df <- input.df[!(is.na(input.df[[response.var]])), ]
  input.df$response.var <- input.df[[response.var]]
  # input.df$Time <- as.factor(input.df$Time)
  input.df$interact <- interaction(input.df$Experiment, input.df$Inj_Cell)
  
  input.df$Phase <- "None"
  input.df[input.df$Condition %in% c("PS.45", "PS.22.High.Amp"), "Phase"] <- "Offset"
  input.df[input.df$Condition %in% c("PS.0", "PS.0.High.Amp"), "Phase"] <- "Normal"
  input.df$Amp <- "None"
  # input.df[input.df$Condition %in% c("PS.0.High.Amp", "PS.22.High.Amp"), "Amp"] <- "High"
  # input.df[input.df$Condition %in% c("PS.0", "PS.45"), "Amp"] <- "Normal"
  
  input.df <- input.df[, c("response.var", "interact", "Time", "Phase", "Amp")]
  
  # First model with observed data
  fm <- lme(response.var ~ Time * Phase #+ Time * Amp + Phase * Amp
            , random = ~1 | interact, method = "ML", data = input.df)
  
  
  stats.table <- anova.lme(fm)
  
  F_stats <- matrix(NA, nrow = nreps, ncol = length(stats.table$`F-value`))
  F_stats[1, ] <- stats.table$`F-value`
  
  
  set.seed(use.seed)
  for (ii in 2:nreps) {
    
    if (mute.completion != TRUE){
      print(paste0(((ii/nreps)*100), "%"))
    }
    rand.lme <- try(lme(sample(response.var) ~ Time * Phase #+ Time * Amp + Phase * Amp
                        , random = ~1 | interact, method = "ML", data = input.df))
    
    
    F_stats[ii, ] <- try(anova.lme(rand.lme)$`F-value`)
    
    
    # In case there is a convergence issue we immediately replace that value to get the target number of reps. 
    while (is.na(as.numeric(F_stats[ii, 1]))) {
      print("Replacing model with singular convergence")
      rand.lme <- try(lme(sample(response.var) ~ Time * Phase #+ Time * Amp + Phase * Amp
                          , random = ~1 | interact, method = "ML", data = input.df))
      
      
      F_stats[ii, ] <- try(anova.lme(rand.lme)$`F-value`)
      
    }
  }
  
  F_stats <- as.data.frame(F_stats)
  names(F_stats) <- rownames(stats.table)
  
  #Convert from factor/cha to int
  walk(1:4, function(X){
    F_stats[,X] <<- as.numeric(F_stats[,X])
  })
  toc <- Sys.time()
  
  if (mute.time != TRUE){
    print(toc - tic)    
  }
  return(na.omit(F_stats))
}






```

```{r perform resampling, eval=FALSE}
if (resample.results == TRUE){
  tic1 <- Sys.time()
  me_cell <- purrr::map(c("r11", "r1", "cc"
                          # , "htk.peak.nA", "a.peak.nA"
                          ), function(x) {
    run_standardized_lme_resample_HA(
      response.var = x,
      input.df = M[M$Condition %in% c("PS.0.High.Amp", "PS.22.High.Amp"), ],
      nreps = resample.nreps,
      use.seed = 432431,
      mute.completion = TRUE,
      mute.time = FALSE
    )
  })
  
  me_exps <- purrr::map(c("rc", "gj"), function(x) {
    run_standardized_lme_resample_HA(
      response.var = x,
      input.df = M.gj[M.gj$Condition %in% c("PS.0.High.Amp", "PS.22.High.Amp"), ],
      nreps = resample.nreps,
      use.seed = 432431,
      mute.completion = TRUE,
      mute.time = FALSE
    )
  })
  toc1 <- Sys.time()
  print(toc1 - tic1)
  
  # Restructure into a single list of all outputs
  me_all <- list()
  walk(seq_along(me_cell), function(X){ me_all[[length(me_all)+1]] <<- me_cell[[X]] })
  walk(seq_along(me_exps), function(X){ me_all[[length(me_all)+1]] <<- me_exps[[X]] })
  
  saveRDS(me_all, file = paste0(getwd(), "/data/output/", "rHighAmp_model_results", ".rds"))
  write.csv(me_all, file = paste0(getwd(), "/data/output/", "rHighAmp_model_results", ".csv"))
} else {
  me_all <- readRDS(paste0(getwd(), "/data/", "rHighAmp_model_results", ".rds"))
}

```

```{r calc empirical p, eval=FALSE}
# Main effect empirical p values
measures <- c("r11", "r1", 
              "cc", 
              # "htk.peak.nA", "a.peak.nA",
              "rc", 
              "gj")
out <- as.data.frame(matrix(ncol = 4, nrow = length(measures)))
names(out) <- c("Intercept", "Time", "Phase", "Time:Phase")
rownames(out) <- measures

walk(seq_along(measures), function(i){
  walk(1:4, function(j){
    out[i, j] <<- one_tail_to_epval(input.array = me_all[[i]][,j], tail = "upper")
  })
})


out.holm <- t(out) %>% as.data.frame()
walk(1:ncol(out.holm), function(i){
  out.holm[,i] <<- p.adjust(out.holm[,i], method = "holm") 
})
out.holm <- t(out.holm) %>% as.data.frame()


knitr::kable(out)
knitr::kable(out.holm)

# write.csv(out, paste0(getwd(), "/epvals_phase.csv"))
# write.csv(out.holm, paste0(getwd(), "/epvals_holm_phase.csv"))

write.csv(out, paste0(getwd(), "/data/output/", "rHighAmp_model_pvals", ".csv"))
write.csv(out.holm, paste0(getwd(), "/data/output/", "rHighAmp_model_pvals_holm", ".csv"))
# write.csv(out.holm, paste0("C:/Users/Daniel/Desktop/epvals_holm_phase.csv"))

```

2x2
```{r perform resampling, eval=FALSE}
if (resample.results == TRUE){
  tic1 <- Sys.time()
  me_cell <- purrr::map(c("r11", "r1", "cc"
                          # , "htk.peak.nA", "a.peak.nA"
                          ), function(x) {
    run_standardized_lme_resample(
      response.var = x,
      input.df = M[M$Condition %in% c("PS.0.High.Amp", "PS.0", "PS.22", "PS.22.High.Amp"), ],
      nreps = resample.nreps,
      use.seed = 432431,
      mute.completion = TRUE,
      mute.time = FALSE
    )
  })
  
  me_exps <- purrr::map(c("rc", "gj"), function(x) {
    run_standardized_lme_resample(
      response.var = x,
      input.df = M.gj[M.gj$Condition %in% c("PS.0.High.Amp", "PS.0", "PS.22", "PS.22.High.Amp"), ],
      nreps = resample.nreps,
      use.seed = 432431,
      mute.completion = TRUE,
      mute.time = FALSE
    )
  })
  toc1 <- Sys.time()
  print(toc1 - tic1)
  
  # Restructure into a single list of all outputs
  me_all <- list()
  walk(seq_along(me_cell), function(X){ me_all[[length(me_all)+1]] <<- me_cell[[X]] })
  walk(seq_along(me_exps), function(X){ me_all[[length(me_all)+1]] <<- me_exps[[X]] })
  
  saveRDS(me_all, file = paste0(getwd(), "/data/output/", "r2x2_model_results", ".rds"))
  write.csv(me_all, file = paste0(getwd(), "/data/output/", "r2x2_model_results", ".csv"))
} else {
  me_all <- readRDS(paste0(getwd(), "/data/output/", "r2x2_model_results", ".rds"))
}

```

```{r calc empirical p, eval=FALSE}
# Main effect empirical p values
measures <- c("r11", "r1", 
              "cc", 
              # "htk.peak.nA", "a.peak.nA",
              "rc", 
              "gj")
out <- as.data.frame(matrix(ncol = 7, nrow = length(measures)))
names(out) <- c("Intercept", "Time", "Phase", "Amp", "Time:Phase", "Time:Amp", "Phase:Amp")
rownames(out) <- measures

walk(seq_along(measures), function(i){
  walk(1:7, function(j){
    out[i, j] <<- one_tail_to_epval(input.array = me_all[[i]][,j], tail = "upper")
  })
})


out.holm <- t(out) %>% as.data.frame()
walk(1:ncol(out.holm), function(i){
  out.holm[,i] <<- p.adjust(out.holm[,i], method = "holm") 
})
out.holm <- t(out.holm) %>% as.data.frame()


knitr::kable(out)
knitr::kable(out.holm)

write.csv(out, paste0(getwd(), "/data/output/", "r2x2_model_pvals", ".csv"))
write.csv(out.holm, paste0(getwd(), "/data/output/", "r2x2_model_pvals_holm", ".csv"))
```

2x2 using _45_
```{r perform resampling, eval=FALSE}
if (resample.results == TRUE){
  tic1 <- Sys.time()
  me_cell <- purrr::map(c("r11", "r1", "cc"
                          # , "htk.peak.nA", "a.peak.nA"
                          ), function(x) {
    run_standardized_lme_resample_W_45(
      response.var = x,
      input.df = M[M$Condition %in% c("PS.0.High.Amp", "PS.0", "PS.45", "PS.22.High.Amp"), ],
      nreps = resample.nreps,
      use.seed = 432431,
      mute.completion = TRUE,
      mute.time = FALSE
    )
  })
  
  me_exps <- purrr::map(c("rc", "gj"), function(x) {
    run_standardized_lme_resample_W_45(
      response.var = x,
      input.df = M.gj[M.gj$Condition %in% c("PS.0.High.Amp", "PS.0", "PS.45", "PS.22.High.Amp"), ],
      nreps = resample.nreps,
      use.seed = 432431,
      mute.completion = TRUE,
      mute.time = FALSE
    )
  })
  toc1 <- Sys.time()
  print(toc1 - tic1)
  
  # Restructure into a single list of all outputs
  me_all <- list()
  walk(seq_along(me_cell), function(X){ me_all[[length(me_all)+1]] <<- me_cell[[X]] })
  walk(seq_along(me_exps), function(X){ me_all[[length(me_all)+1]] <<- me_exps[[X]] })
  
  saveRDS(me_all, file = paste0(getwd(), "/data/output/", "r2x2_W_45_model_results", ".rds"))
  write.csv(me_all, file = paste0(getwd(), "/data/output/", "r2x2_W_45_model_results", ".csv"))
} else {
  me_all <- readRDS(paste0(getwd(), "/data/output/", "r2x2_W_45_model_results", ".rds"))
}

```


```{r calc empirical p, eval=FALSE}
# Main effect empirical p values
measures <- c("r11", "r1", 
              "cc", 
              # "htk.peak.nA", "a.peak.nA",
              "rc", 
              "gj")
out <- as.data.frame(matrix(ncol = 7, nrow = length(measures)))
names(out) <- c("Intercept", "Time", "Phase", "Amp", "Time:Phase", "Time:Amp", "Phase:Amp")
rownames(out) <- measures

walk(seq_along(measures), function(i){
  walk(1:7, function(j){
    out[i, j] <<- one_tail_to_epval(input.array = me_all[[i]][,j], tail = "upper")
  })
})


out.holm <- t(out) %>% as.data.frame()
walk(1:ncol(out.holm), function(i){
  out.holm[,i] <<- p.adjust(out.holm[,i], method = "holm") 
})
out.holm <- t(out.holm) %>% as.data.frame()


knitr::kable(out)
knitr::kable(out.holm)

write.csv(out, paste0(getwd(), "/data/output/", "r2x2_W_45_model_pvals", ".csv"))
write.csv(out.holm, paste0(getwd(), "/data/output/", "r2x2_W_45_model_pvals_holm", ".csv"))
```


## stats tables ANOVA on t = 40 deltas
Controlled
```{r eval=FALSE, include=FALSE}
d <- M.d.gj
d <- d %>% 
  dplyr::select(c("Condition", "Experiment", "Time", "gj")) %>% 
  dplyr::filter(Condition %in% c(
    # "PS.0.orig",
    # "PS.22.orig",
    # "PS.45.orig",
    # "PS.90.orig",
    # "PS.180.orig",
    
    "PS.0",
    "PS.22",
    "PS.45",
    "PS.90"#,
    
    # "PS.0.High.Amp",
    # "PS.22.High.Amp",
    # 
    # "Inv",
    # "PS.0.TEA",
    # "Silent.53mV"
  )) 

# d <- d[is.na(d$Condition),]
d$Condition <- factor(d$Condition, levels = c(
  "PS.0",
  "PS.22",
  "PS.45",
  "PS.90"))

aov_tab <- data.frame()
hsd_tab <- data.frame()
walk(c(20, 40, 60), function(i){
# for (i in c(20, 40, 60)){
  print(paste(as.character(i), "minutes"))
  fm <- lm(gj ~ Condition,   dplyr::filter(d, Time == i))
  print(Anova(fm, type = "III"))
  fm_T <- agricolae::HSD.test(fm, "Condition")
  print(fm_T$groups)
# }
  
  t1 <- Anova(fm, type = "III")
  t1$endpoint <- i
  t2 <- fm_T$groups
  t2$endpoint <- i
  
aov_tab <<- rbind(aov_tab, t1)
hsd_tab <<- rbind(hsd_tab, t2)  
})



write.csv(aov_tab, "./data/output/aovCon.csv")
write.csv(hsd_tab, "./data/output/hsdCon.csv")
```

## rstanarm
Controlled rstanarm
```{r eval=FALSE, include=FALSE}
d <- M.gj
d <- d %>% 
  dplyr::select(c("Condition", "Experiment", "Time", "gj")) %>% 
  dplyr::filter(Condition %in% c(
    # "PS.0.orig",
    # "PS.22.orig",
    # "PS.45.orig",
    # "PS.90.orig",
    # "PS.180.orig",
    
    "PS.0",
    "PS.22",
    "PS.45",
    "PS.90"#,
    
    # "PS.0.High.Amp",
    # "PS.22.High.Amp",
    # 
    # "Inv",
    # "PS.0.TEA",
    # "Silent.53mV"
  )) 

# d <- d[is.na(d$Condition),]
d$Condition <- factor(d$Condition, levels = c(
  "PS.0",
  "PS.22",
  "PS.45",
  "PS.90"))

d$Time <- as.factor(d$Time)
d$Time <- factor(d$Time, levels = c(0, 20, 40, 60))

d$interact <- paste(d$Experiment, d$Inj_Cell, sep = ".")

model <- rstanarm::stan_lmer(gj ~ Time * Condition + (1 | Experiment), data = d)

#PD
result <- p_direction(model)
plot(result) + theme_modern() + scale_fill_manual(values = c("firebrick", "steelblue"))

ggsave(
      "PD.Con.pdf",
      plot = ggplot2::last_plot(),
      device = NULL,
      path = paste0(getwd(), "/data/figures"),
width = 9.4, height = 9.4,
      # units = c("in", "cm", "mm"),
      dpi = 75#, limitsize = TRUE, ...
    )

#HDI
# result <- hdi(model, ci = c(0.67, 0.89, 0.97))
# plot(result) + theme_modern() + scale_fill_brewer(palette = "Blues", 
#     direction = -1)

#ROPE
# result <- rope(model, ci = c(0.9, 0.95))
# 
# plot(result, data = model, rope_color = "firebrick") + theme_modern() + 
#     scale_fill_brewer(palette = "Blues", direction = -1)

#Test for Practical Equivalence
result <- equivalence_test(model, ci = c(0.95))
plot(result) + theme_modern() + scale_fill_manual(values = c("firebrick", "steelblue"))

ggsave(
      "CI95.Con.pdf",
      plot = ggplot2::last_plot(),
      device = NULL,
      path = paste0(getwd(), "/data/figures"),
width = 9.4, height = 9.4,
      # units = c("in", "cm", "mm"),
      dpi = 75#, limitsize = TRUE, ...
    )

write.csv(describe_posterior(model, ci = 0.95, rope_ci = 0.95), paste0(getwd(), "/data/output/", "bayesCon", ".csv"))
```

Naturalistic
```{r eval=FALSE, include=FALSE}
d <- M.d.gj
d <- d %>% 
  dplyr::select(c("Condition", "Experiment", "Time", "rc")) %>% 
  dplyr::filter(Condition %in% c(
    "PS.0.orig",
    "PS.22.orig",
    "PS.45.orig",
    "PS.90.orig",
    "PS.180.orig"#,
    
    # "PS.0",
    # "PS.22",
    # "PS.45",
    # "PS.90",
    
    # "PS.0.High.Amp",
    # "PS.22.High.Amp",
    # 
    # "Inv",
    # "PS.0.TEA",
    # "Silent.53mV"
  )) 

# d <- d[is.na(d$Condition),]
d$Condition <- factor(d$Condition, levels = c(
  "PS.0.orig",
  "PS.22.orig",
  "PS.45.orig",
  "PS.90.orig",
  "PS.180.orig"))

aov_tab <- data.frame()
hsd_tab <- data.frame()
walk(c(20, 40, 60), function(i){
# for (i in c(20, 40, 60)){
  print(paste(as.character(i), "minutes"))
  fm <- lm(rc ~ Condition,   dplyr::filter(d, Time == i))
  print(Anova(fm, type = "III"))
  fm_T <- agricolae::HSD.test(fm, "Condition")
  print(fm_T$groups)
# }
    t1 <- Anova(fm, type = "III")
  t1$endpoint <- i
  t2 <- fm_T$groups
  t2$endpoint <- i
  
aov_tab <<- rbind(aov_tab, t1)
hsd_tab <<- rbind(hsd_tab, t2)  
})

write.csv(aov_tab, "./data/output/aovNat.csv")
write.csv(hsd_tab, "./data/output/hsdNat.csv")
```

Naturalistic rstanarm
```{r eval=FALSE, include=FALSE}
d <- M.gj
d <- d %>% 
  dplyr::select(c("Condition", "Experiment", "Time", "rc")) %>% 
  dplyr::filter(Condition %in% c(
    "PS.0.orig",
    "PS.22.orig",
    "PS.45.orig",
    "PS.90.orig",
    "PS.180.orig"#,
    
    # "PS.0",
    # "PS.22",
    # "PS.45",
    # "PS.90",
    
    # "PS.0.High.Amp",
    # "PS.22.High.Amp",
    # 
    # "Inv",
    # "PS.0.TEA",
    # "Silent.53mV"
  )) 

# d <- d[is.na(d$Condition),]
d$Condition <- factor(d$Condition, levels = c(
  "PS.0.orig",
  "PS.22.orig",
  "PS.45.orig",
  "PS.90.orig",
  "PS.180.orig"))

d$Time <- as.factor(d$Time)
d$Time <- factor(d$Time, levels = c(0, 20, 40, 60))

d$interact <- paste(d$Experiment, d$Inj_Cell, sep = ".")

model <- rstanarm::stan_lmer(rc ~ Time * Condition + (1 | Experiment), data = d)
# model <- rstanarm::stan_glm(rc ~ Time * Condition + Experiment, data = d)

#PD
result <- p_direction(model)
plot(result) + theme_modern() + scale_fill_manual(values = c("firebrick", "steelblue"))

ggsave(
      "PD.Nat.pdf",
      plot = ggplot2::last_plot(),
      device = NULL,
      path = paste0(getwd(), "/data/figures"),
width = 9.4, height = 9.4,
      # units = c("in", "cm", "mm"),
      dpi = 75#, limitsize = TRUE, ...
    )

#HDI
# result <- hdi(model, ci = c(0.67, 0.89, 0.97))
# plot(result) + theme_modern() + scale_fill_brewer(palette = "Blues", 
#     direction = -1)

#ROPE
# result <- rope(model, ci = c(0.9, 0.95))
# 
# plot(result, data = model, rope_color = "firebrick") + theme_modern() + 
#     scale_fill_brewer(palette = "Blues", direction = -1)

#Test for Practical Equivalence
result <- equivalence_test(model, ci = c(0.95))
plot(result) + theme_modern() + scale_fill_manual(values = c("firebrick", "steelblue"))

ggsave(
      "CI95.Nat.pdf",
      plot = ggplot2::last_plot(),
      device = NULL,
      path = paste0(getwd(), "/data/figures"),
width = 9.4, height = 9.4,
      # units = c("in", "cm", "mm"),
      dpi = 75#, limitsize = TRUE, ...
    )

write.csv(describe_posterior(model, ci = 0.95, rope_ci = 0.95), paste0(getwd(), "/data/output/", "bayesNat", ".csv"))
```

2x2
```{r eval=FALSE, include=FALSE}
d <- M.d.gj
# d <- M.gj
d <- d %>% 
  dplyr::select(c("Condition", "Experiment", "Inj_Cell", "Time", "gj")) %>% 
  dplyr::filter(Condition %in% c(
    # "PS.0.orig",
    # "PS.22.orig",
    # "PS.45.orig",
    # "PS.90.orig",
    # "PS.180.orig",
    
    "PS.0",
    "PS.22",
    # "PS.45",
    # "PS.90",
    
    "PS.0.High.Amp",
    "PS.22.High.Amp"#,
    # 
    # "Inv",
    # "PS.0.TEA",
    # "Silent.53mV"
  )) 


d$Amp <- ifelse(d$Condition %in% c("PS.0", "PS.22"), "low", "high")
d$Phase <- ifelse(d$Condition %in% c("PS.0", "PS.0.High.Amp"), "0", "22.5")

d$Amp <- as.factor(d$Amp)
d$Amp <- factor(d$Amp, levels = c("low", "high"))

d$Phase <- as.factor(d$Phase)
d$Phase <- factor(d$Phase, levels = c("0", "22.5"))


aov_tab <- data.frame()
hsd_tab <- data.frame()
walk(c(20, 40, 60), function(i){
# for (i in c(20, 40, 60)){
  print(paste(as.character(i), "minutes"))
  fm <- lm(gj ~ Phase*Amp,   dplyr::filter(d, Time == i))
  print(Anova(fm, type = "III"))
  fm_T <- agricolae::HSD.test(fm, c("Phase", "Amp"))
  print(fm_T$groups)
# }
  t1 <- Anova(fm, type = "III")
  t1$endpoint <- i
  t2 <- fm_T$groups
  t2$endpoint <- i
  
aov_tab <<- rbind(aov_tab, t1)
hsd_tab <<- rbind(hsd_tab, t2)  
})

write.csv(aov_tab, "./data/output/aov2x2.csv")
write.csv(hsd_tab, "./data/output/hsd2x2.csv")



# # model <- rstanarm::stan_glm(Sepal.Length ~ Petal.Width * Species,
# #     data = iris)
# 
# 
# d$interact <- paste(d$Experiment, d$Inj_Cell, sep = ".")
# 
# #   fm <- lme(gj ~ Time * Phase + Time * Amp + Phase * Amp, random = ~1 | interact, method = "ML", data = d)
# 
# 
# d$Time <- as.factor(d$Time)
# d$Time <- factor(d$Time, levels = c(0, 20, 40, 60))
# 
# # model <- rstanarm::stan_lmer(gj ~ Time * Phase + Time * Amp + Phase * Amp + (1 | interact), data = d)
# 
# ggplot(dplyr::filter(d, Time == 40), aes(x = Condition, y = gj))+
#   geom_hline(yintercept = 0)+
#   geom_boxplot()+
#   geom_point(aes(color = Condition), size = 2)+
#   kickme()
# 
# 
# model <- rstanarm::stan_glm(gj ~ Phase*Amp,
#                             # prior = student_t(),
#           data = dplyr::filter(d, Time == 40))
# 
# 
# result <- estimate_density(model)
# 
# plot(result)
# 
# 
# #PI
# result <- p_direction(model)
# 
# plot(result) + theme_modern() + scale_fill_manual(values = c("firebrick", "steelblue"))
# 
# #HDI
# result <- hdi(model, ci = c(0.67, 0.89, 0.97))
# 
# plot(result) + theme_modern() + scale_fill_brewer(palette = "Blues",
#     direction = -1)
# 
# #ROPE
# result <- rope(model, ci = c(0.9, 0.95))
# 
# plot(result, data = model, rope_color = "firebrick") + theme_modern() +
#     scale_fill_brewer(palette = "Blues", direction = -1)
# 
# #Test for Practical Equivalence
# 
# result <- equivalence_test(model)
# 
# plot(result) + theme_blackboard() + scale_fill_material()
# 
# 
# result <- equivalence_test(model, ci = c(0.92, 0.94, 0.95))
# plot(result) + theme_abyss() + scale_fill_flat()
```

2x2 rstanarm
```{r eval=FALSE, include=FALSE}
d <- M.gj
# d <- M.gj
d <- d %>% 
  dplyr::select(c("Condition", "Experiment", "Inj_Cell", "Time", "gj")) %>% 
  dplyr::filter(Condition %in% c(
    # "PS.0.orig",
    # "PS.22.orig",
    # "PS.45.orig",
    # "PS.90.orig",
    # "PS.180.orig",
    
    "PS.0",
    "PS.22",
    # "PS.45",
    # "PS.90",
    
    "PS.0.High.Amp",
    "PS.22.High.Amp"#,
    # 
    # "Inv",
    # "PS.0.TEA",
    # "Silent.53mV"
  )) 


d$Amp <- ifelse(d$Condition %in% c("PS.0", "PS.22"), "low", "high")
d$Phase <- ifelse(d$Condition %in% c("PS.0", "PS.0.High.Amp"), "0", "22.5")

d$Amp <- as.factor(d$Amp)
d$Amp <- factor(d$Amp, levels = c("low", "high"))

d$Phase <- as.factor(d$Phase)
d$Phase <- factor(d$Phase, levels = c("0", "22.5"))


d$Time <- as.factor(d$Time)
d$Time <- factor(d$Time, levels = c(0, 20, 40, 60))

d$interact <- paste(d$Experiment, d$Inj_Cell, sep = ".")

model <- rstanarm::stan_lmer(gj ~ Time * Phase + Time * Amp + Phase * Amp + (1 | interact), data = d)


#PD
result <- p_direction(model)
plot(result) + theme_modern() + scale_fill_manual(values = c("firebrick", "steelblue"))

ggsave(
      "PD.2x2.pdf",
      plot = ggplot2::last_plot(),
      device = NULL,
      path = paste0(getwd(), "/data/figures"),
width = 9.4, height = 9.4,
      # units = c("in", "cm", "mm"),
      dpi = 75#, limitsize = TRUE, ...
    )

#HDI
# result <- hdi(model, ci = c(0.67, 0.89, 0.97))
# plot(result) + theme_modern() + scale_fill_brewer(palette = "Blues", 
#     direction = -1)

#ROPE
# result <- rope(model, ci = c(0.9, 0.95))
# 
# plot(result, data = model, rope_color = "firebrick") + theme_modern() + 
#     scale_fill_brewer(palette = "Blues", direction = -1)

#Test for Practical Equivalence
result <- equivalence_test(model, ci = c(0.95))
plot(result) + theme_modern() + scale_fill_manual(values = c("firebrick", "steelblue"))

ggsave(
      "CI95.2x2.pdf",
      plot = ggplot2::last_plot(),
      device = NULL,
      path = paste0(getwd(), "/data/figures"),
width = 9.4, height = 9.4,
      # units = c("in", "cm", "mm"),
      dpi = 75#, limitsize = TRUE, ...
    )

write.csv(describe_posterior(model, ci = 0.95, rope_ci = 0.95), paste0(getwd(), "/data/output/", "bayes2x2", ".csv"))
```






Naturalistic rstanarm
```{r eval=FALSE, include=FALSE}
d <- M.gj
d <- d %>% 
  dplyr::select(c("Condition", "Experiment", "Time", "rc")) %>% 
  dplyr::filter(Condition %in% c(
    "PS.0.orig",
    "PS.22.orig",
    "PS.45.orig",
    "PS.90.orig",
    # "PS.180.orig"#,
    
    "PS.0",
    "PS.22",
    "PS.45",
    "PS.90",
    
    "PS.0.High.Amp",
    "PS.22.High.Amp"
    # 
    # "Inv",
    # "PS.0.TEA",
    # "Silent.53mV"
  )) 

d$Condition <- as.character(d$Condition)

d[d$Condition %in% c("PS.0.orig",
    "PS.0",
    "PS.0.High.Amp"), "Condition"] <- "0"

d[d$Condition %in% c(
    "PS.22.orig",
    "PS.22",
    "PS.22.High.Amp"), "Condition"] <- "22.5"

d[d$Condition %in% c(
    "PS.45.orig",
    "PS.45"
), "Condition"] <- "45"

d[d$Condition %in% c("PS.90.orig",
    
    "PS.90"), "Condition"] <- "90"


d$Condition <- as.factor(d$Condition)
# d <- d[is.na(d$Condition),]
d$Condition <- factor(d$Condition, levels = c(
  "0",
  "22.5",
  "45",
  "90"))

d$Time <- as.factor(d$Time)
d$Time <- factor(d$Time, levels = c(0, 20, 40, 60))

d$interact <- paste(d$Experiment, d$Inj_Cell, sep = ".")

model <- rstanarm::stan_lmer(rc ~ Time * Condition + (1 | Experiment), data = d)
# model <- rstanarm::stan_glm(rc ~ Time * Condition + Experiment, data = d)

# plot(model$coefficients)

#PD
result <- p_direction(model)
plot(result) + theme_modern() + scale_fill_manual(values = c("firebrick", "steelblue"))

ggsave(
      "PD.Nat.pdf",
      plot = ggplot2::last_plot(),
      device = NULL,
      path = paste0(getwd(), "/data/figures"),
width = 9.4, height = 9.4,
      # units = c("in", "cm", "mm"),
      dpi = 75#, limitsize = TRUE, ...
    )

#HDI
result <- hdi(model, ci = c(0.67, 0.89, 0.97))
plot(result) + theme_modern() + scale_fill_brewer(palette = "Blues",
    direction = -1)

#ROPE
result <- rope(model, ci = c(0.9, 0.95))

plot(result, data = model, rope_color = "firebrick") + theme_modern() +
    scale_fill_brewer(palette = "Blues", direction = -1)

#Test for Practical Equivalence
result <- equivalence_test(model, ci = c(0.95))
plot(result) + theme_modern() + scale_fill_manual(values = c("firebrick", "steelblue"))

# ggsave(
#       "CI95.Nat.pdf",
#       plot = ggplot2::last_plot(),
#       device = NULL,
#       path = paste0(getwd(), "/data/figures"),
# width = 9.4, height = 9.4,
#       # units = c("in", "cm", "mm"),
#       dpi = 75#, limitsize = TRUE, ...
#     )

# write.csv(describe_posterior(model, ci = 0.95, rope_ci = 0.95), paste0(getwd(), "/data/output/", "bayesNat", ".csv"))

# fit <- stan_glm(mpg ~ ., data = mtcars)
posterior <- as.matrix(model)

plot_title <- ggtitle("Posterior distributions",
                      "with medians and 80% intervals")

library(bayesplot)
mcmc_areas(posterior,
           pars = c("Time60:Condition22.5", "Time60:Condition45", "Time60:Condition90")[3:1],
           prob = 0.8) + plot_title+
  coord_flip()


#see
result <- estimate_density(model)

result$Parameter %>% unique()

plot(result[result[,1] %in% c("Time60:Condition22.5", "Time60:Condition45", "Time60:Condition90"),])
```









## For SFN Abstract

```{r eval=FALSE, include=FALSE}
# median delta
median(M.d.gj[M.d.gj$Condition %in% c("PS.22") & M.d.gj$Time == 60, "rc"], na.rm = T)
median(M.d.gj[M.d.gj$Condition %in% c("PS.90") & M.d.gj$Time == 60, "rc"], na.rm = T)
```



```{r eval=FALSE, include=FALSE}

response.var = "rc"
input.df = M.gj[M.gj$Condition %in% c("PS.0", "PS.22", "PS.45", "PS.90"), ]
nreps = 100
use.seed = 432431
mute.completion = FALSE
mute.time = FALSE

  
  
  tic <- Sys.time()

  # Transform the data so that it's ready for the test
  input.df <- input.df[!(is.na(input.df[[response.var]])), ]
  input.df$response.var <- input.df[[response.var]]
  # input.df$Time <- as.factor(input.df$Time)
  input.df$interact <- interaction(input.df$Experiment, input.df$Inj_Cell)

  input.df$Phase <- "None"
  
  input.df[input.df$Condition %in% c("PS.0"),  "Phase"] <- "0"
  input.df[input.df$Condition %in% c("PS.22"), "Phase"] <- "22"
  input.df[input.df$Condition %in% c("PS.45"), "Phase"] <- "45"
  input.df[input.df$Condition %in% c("PS.90"), "Phase"] <- "90"
  

  input.df <- input.df[, c("response.var", "interact", "Time", "Phase"
                           # , "Amp"
                           )]

  # First model with observed data
  fm <- lme(response.var ~ Time * Phase, random = ~1 | interact, method = "ML", data = input.df)
  stats.table <- anova.lme(fm)
```


```{r eval=FALSE, include=FALSE}
response.var = "rc"
input.df = M.gj[M.gj$Condition %in% c("PS.0.High.Amp", "PS.0", "PS.22", "PS.22.High.Amp"), ]
mute.time = FALSE


tic <- Sys.time()

# Transform the data so that it's ready for the test
input.df <- input.df[!(is.na(input.df[[response.var]])), ]
input.df$response.var <- input.df[[response.var]]
# input.df$Time <- as.factor(input.df$Time)
input.df$interact <- interaction(input.df$Experiment, input.df$Inj_Cell)

input.df$Phase <- "None"
input.df[input.df$Condition %in% c("PS.22", "PS.22.High.Amp"), "Phase"] <- "Offset"
input.df[input.df$Condition %in% c("PS.0", "PS.0.High.Amp"), "Phase"] <- "Normal"
input.df$Amp <- "None"
input.df[input.df$Condition %in% c("PS.0.High.Amp", "PS.22.High.Amp"), "Amp"] <- "High"
input.df[input.df$Condition %in% c("PS.0", "PS.22"), "Amp"] <- "Normal"

input.df <- input.df[, c("response.var", "interact", "Time", "Phase", "Amp")]

# First model with observed data
fm <- lme(response.var ~ Time * Phase + Time * Amp + Phase * Amp, random = ~1 | interact, method = "ML", data = input.df)
stats.table <- anova.lme(fm)
```

# end for now
```{r}
#FIXME temp end
print(paste0("Completed in ", as.character(Sys.time()-ttock)))
# 3h, 10m
```


# Link to Frankenstein experiments
